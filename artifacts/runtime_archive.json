{
"packages/case_conversion/src/mod.ts":"export function camelify(snake: string) {\n\tconst partial = snake.replace(/_([a-z])/g, (g) => (g[1] ?? \"\").toUpperCase());\n\treturn (partial[0] ?? \"\").toLowerCase() + partial.slice(1);\n}\n\nexport function pascalify(snake: string) {\n\tconst camel = camelify(snake);\n\treturn (camel[0] ?? \"\").toUpperCase() + camel.slice(1);\n}\n\nexport function snakeify(camel: string) {\n\treturn camel.replace(/[A-Z]/g, (g) => `_${g.toLowerCase()}`);\n}\n",
"packages/path_resolver/src/mod.ts":"export type PathPair = { path: string; isPrefix: boolean };\n\nexport interface QualifiedPathPair {\n\tmodule: string;\n\troute: string;\n\tpath: PathPair;\n}\n\n/**\n * A class to resolve paths to their associated {@link QualifiedPathPair}.\n *\n * This is used to look up `QualifiedPathPair` values by the requested path.\n */\nexport class PathResolver {\n\tprivate readonly exactRoutes: Map<string, QualifiedPathPair> = new Map();\n\tprivate readonly prefixRoutes: Map<string, QualifiedPathPair> = new Map();\n\n\tprivate _collisions: Set<QualifiedPathPair> | undefined = undefined;\n\n\tpublic constructor(routes: QualifiedPathPair[]) {\n\t\tfor (const route of routes) {\n\t\t\tconst { isPrefix, path } = route.path;\n\t\t\tif (isPrefix) {\n\t\t\t\tthis.prefixRoutes.set(path, route);\n\t\t\t} else {\n\t\t\t\tthis.exactRoutes.set(path, route);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A utility function to ensure that there are no collisions between paths.\n\t *\n\t * This function is used in the constructor to ensure that no path is a child\n\t * of a prefix and no prefix is the ancestor of any path.\n\t *\n\t * @param paths The paths to check for collisions\n\t *\n\t * @throws `Error` if any paths are found to collide\n\t */\n\tprivate static getCollisions(routes: QualifiedPathPair[]) {\n\t\tconst bannedPrefixes = new Map<string, QualifiedPathPair>();\n\n\t\tconst takenPrefixes = new Map<string, QualifiedPathPair>();\n\t\tconst takenExact = new Map<string, QualifiedPathPair>();\n\n\t\tconst issuePaths = new Set<QualifiedPathPair>();\n\n\t\tfor (const routeInfo of routes) {\n\t\t\tconst path = routeInfo.path;\n\n\t\t\t// Make sure it is not exactly the same as any other exact path\n\t\t\tconst takingRoute = takenExact.get(path.path);\n\t\t\tif (takingRoute) {\n\t\t\t\tissuePaths.add(takingRoute);\n\t\t\t\tissuePaths.add(routeInfo);\n\t\t\t}\n\n\t\t\t// Make sure it is not a child of any prefixed path\n\t\t\tfor (const ancestor of pathAncestors(path.path)) {\n\t\t\t\tconst conflictingPrefix = takenPrefixes.get(ancestor);\n\t\t\t\tif (conflictingPrefix) {\n\t\t\t\t\tissuePaths.add(conflictingPrefix);\n\t\t\t\t\tissuePaths.add(routeInfo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the path is a prefix:\n\t\t\tif (path.isPrefix) {\n\t\t\t\t// Make sure it is not an ancestor of any other registered path\n\t\t\t\t// (prefix or exact)\n\t\t\t\tconst conflictingChild = bannedPrefixes.get(path.path);\n\t\t\t\tif (conflictingChild) {\n\t\t\t\t\tissuePaths.add(conflictingChild);\n\t\t\t\t\tissuePaths.add(routeInfo);\n\t\t\t\t}\n\n\t\t\t\ttakenPrefixes.set(path.path, routeInfo);\n\t\t\t}\n\n\t\t\t// Mark all ancestors of the path (and the path itself) as banned prefixes\n\t\t\tfor (const ancestor of pathAncestors(path.path)) {\n\t\t\t\tbannedPrefixes.set(ancestor, routeInfo);\n\t\t\t}\n\n\t\t\t// Disallow exact matches for both prefixe and exact\n\t\t\ttakenExact.set(path.path, routeInfo);\n\t\t}\n\n\t\t// if (issuePaths.size > 0) {\n\t\t//     throw new RouteCollisionError(Array.from(issuePaths));\n\t\t// }\n\t\treturn issuePaths;\n\t}\n\n\t/**\n\t * A function to look up `QualifiedPathPair` values by their path.\n\t *\n\t * @param path The pathname the request was made to\n\t * @returns The `T` value associated with the path, whether that is an exact\n\t * or a prefixed path\n\t */\n\tpublic resolve(path: string): QualifiedPathPair | null {\n\t\t// Try to find an exact match first (generally just an optimization)\n\t\tif (this.exactRoutes.has(path)) {\n\t\t\treturn this.exactRoutes.get(path)!;\n\t\t}\n\n\t\t// Iterate over all ancestors of the path and check if any of the\n\t\t// ancestors are a registered prefix.\n\t\t//\n\t\t// This is speedy enough because the runtime is tied to the length of\n\t\t// the path, rather than the number of routes.\n\t\tfor (const prefix of pathAncestors(path)) {\n\t\t\tif (this.prefixRoutes.has(prefix)) {\n\t\t\t\treturn this.prefixRoutes.get(prefix)!;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic get collisions() {\n\t\tlet collisions = this._collisions;\n\t\tif (!collisions) {\n\t\t\tcollisions = PathResolver.getCollisions([\n\t\t\t\t...this.exactRoutes.values(),\n\t\t\t\t...this.prefixRoutes.values(),\n\t\t\t]);\n\t\t\tthis._collisions = collisions;\n\t\t}\n\t\treturn Array.from(collisions).map((o) => Object.freeze(o));\n\t}\n}\n\n/**\n * Resolves a path to a `QualifiedPathPair` only once.\n *\n * This is used in Cloudflare workers, where we only need to resolve the path\n * once per instance of the runtime, and cannot optimize path lookup by keeping\n * the resolver in memory.\n *\n * ### NOTE: This may return an invalid result if there are multiple routes that match.\n *\n * @param routes The qualified path routes to match on\n * @param path The url path to resolve\n */\nexport function resolveOnce(routes: QualifiedPathPair[], path: string): QualifiedPathPair | null {\n\tlet currentRoute: QualifiedPathPair | null = null;\n\tconst cleanPath = path.replace(/\\/$/, \"\");\n\n\tfor (const route of routes) {\n\t\tconst { isPrefix, path: routePathWithPossibleSlash } = route.path;\n\t\tconst routePath = routePathWithPossibleSlash.replace(/\\/$/, \"\");\n\n\t\tif (isPrefix) {\n\t\t\tif (cleanPath.startsWith(routePath)) {\n\t\t\t\tcurrentRoute = route;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (cleanPath === routePath) {\n\t\t\t\tcurrentRoute = route;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentRoute;\n}\n\n/**\n * A generator utility function that yields all ancestors of a given path.\n *\n * This includes the inputted path, and is ordered from most deeply nested to\n * least deeply nested.\n *\n * @param path to list the ancestors of\n * @yields Valid ancestor paths as strings\n */\nexport function* pathAncestors(path: string): IterableIterator<string> {\n\tlet remaining = path;\n\twhile (remaining !== \"/\" && remaining) {\n\t\tyield remaining;\n\n\t\tconst lastSlash = remaining.lastIndexOf(\"/\");\n\t\tif (lastSlash === -1) {\n\t\t\tbreak;\n\t\t}\n\t\tremaining = remaining.slice(0, lastSlash);\n\t}\n\n\t// At this point, output the root, just in case someone used a prefix of\n\t// \"/\"\n\tyield \"/\";\n}\n",
"packages/runtime/src/actor/actor.ts":"import { ModuleContextParams } from \"../context.ts\";\nimport { errorToLogEntries } from \"../logger.ts\";\nimport { ActorContext } from \"../mod.ts\";\nimport { ActorInstanceDriver, ScheduleDriver, StorageDriver } from \"./driver.ts\";\n\n/**\n * Actor implementation that user-made actors will extend.\n */\nexport abstract class ActorBase<\n\tInput,\n\tState,\n> {\n\tpublic state!: State;\n\n\tpublic destroyed: boolean = false;\n\n\tprivate backgroundPromises: Promise<void>[] = [];\n\n\tpublic constructor(\n\t\tprivate readonly instanceDriver: ActorInstanceDriver,\n\t\tpublic readonly storage: StorageDriver,\n\t\tpublic readonly schedule: ScheduleDriver,\n\t) {}\n\n\tpublic abstract initialize(ctx: ActorContext<ModuleContextParams>, input: Input): State | Promise<State>;\n\n\t/**\n\t * Runs a promise in the background.\n\t *\n\t * This allows the actor runtime to ensure that a promise completes while\n\t * returning from an RPC request early.\n\t */\n\tprotected runInBackground<Params extends ModuleContextParams>(ctx: ActorContext<Params>, promise: Promise<void>) {\n\t\t// TODO: Should we force save the state?\n\t\t// Add logging to promise and make it non-failable\n\t\tconst nonfailablePromise = promise\n\t\t\t.then(() => ctx.log.trace(\"background promise complete\"))\n\t\t\t.catch((err) => ctx.log.error(\"background promise failed\", ...errorToLogEntries(\"error\", err)));\n\t\tthis.instanceDriver.runInBackground(nonfailablePromise);\n\t}\n\n\t/**\n\t * Forces the state to get saved.\n\t *\n\t * This is helpful if running a long task that may fail later or a background\n\t * job that updates the state.\n\t */\n\tpublic async forceSaveState() {\n\t\tawait this.instanceDriver.forceSaveState();\n\t}\n}\n",
"packages/runtime/src/actor/driver.ts":"import { Trace } from \"../mod.ts\";\n\nexport interface CreateOpts {\n\tmoduleName: string;\n\tactorName: string;\n\tinstanceName: string;\n\tinput: unknown;\n\ttrace: Trace;\n}\n\nexport interface CallOpts {\n\tmoduleName: string;\n\tactorName: string;\n\tinstanceName: string;\n\tfn: string;\n\trequest: unknown;\n\ttrace: Trace;\n}\n\nexport interface GetOrCreateAndCallOpts {\n\tmoduleName: string;\n\tactorName: string;\n\tinstanceName: string;\n\tinput: unknown;\n\tfn: string;\n\trequest: unknown;\n\ttrace: Trace;\n}\n\nexport interface ExistsOpts {\n\tmoduleName: string;\n\tactorName: string;\n\tinstanceName: string;\n}\n\nexport interface DestroyOpts {\n\tmoduleName: string;\n\tactorName: string;\n\tinstanceName: string;\n}\n\nexport interface ActorDriver {\n\tcreateActor(opts: CreateOpts): Promise<void>;\n\tcallActor(opts: CallOpts): Promise<unknown>;\n\tgetOrCreateAndCallActor(opts: GetOrCreateAndCallOpts): Promise<unknown>;\n\tactorExists(opts: ExistsOpts): Promise<boolean>;\n\tdestroyActor(opts: DestroyOpts): Promise<void>;\n}\n\nexport interface ActorInstanceDriver {\n\trunInBackground(promise: Promise<void>): void;\n\tforceSaveState(): Promise<void>;\n}\n\nexport interface StorageDriver {\n\tget<V>(key: string): Promise<V | undefined>;\n\tput<V>(key: string, value: V): Promise<void>;\n\tdelete(key: string): Promise<void>;\n}\n\nexport interface ScheduleDriver {\n\tafter(duration: number, fn: string, request: unknown): void;\n\tat(timestamp: number, fn: string, request: unknown): void;\n}\n",
"packages/runtime/src/actor/drivers/cloudflare_durable_objects/driver.ts":"// This file is only imported when the runtime is `cloudflare_workers_platform`.\n\nimport { Config, Environment } from \"../../../mod.ts\";\nimport { ActorDriver, CallOpts, CreateOpts, DestroyOpts, ExistsOpts, GetOrCreateAndCallOpts } from \"../../driver.ts\";\nimport { handleRpcOutput } from \"./rpc_output.ts\";\nexport { buildGlobalDurableObjectClass } from \"./global_durable_object.ts\";\n\nexport class CloudflareDurableObjectsActorDriver implements ActorDriver {\n\tpublic constructor(public readonly env: Environment, public readonly config: Config) {}\n\n\tasync createActor(opts: CreateOpts): Promise<void> {\n\t\tconst stub = this.getStub(opts.moduleName, opts.actorName, opts.instanceName);\n\t\treturn handleRpcOutput(\n\t\t\tawait stub.init({\n\t\t\t\tmodule: opts.moduleName,\n\t\t\t\tactor: opts.actorName,\n\t\t\t\tinstance: opts.instanceName,\n\t\t\t\tinput: opts.input,\n\t\t\t\ttrace: opts.trace,\n\t\t\t}),\n\t\t);\n\t}\n\n\tasync callActor(opts: CallOpts): Promise<unknown> {\n\t\tconst stub = this.getStub(opts.moduleName, opts.actorName, opts.instanceName);\n\n\t\t// HACK: Fixes \"Type instantiation is excessively deep and possibly infinite.\"\n\t\treturn handleRpcOutput(\n\t\t\tawait stub.callRpc({\n\t\t\t\tfn: opts.fn,\n\t\t\t\trequest: opts.request,\n\t\t\t\ttrace: opts.trace,\n\t\t\t}),\n\t\t);\n\t}\n\n\tasync getOrCreateAndCallActor(opts: GetOrCreateAndCallOpts): Promise<unknown> {\n\t\tconst stub = this.getStub(opts.moduleName, opts.actorName, opts.instanceName);\n\n\t\t// HACK: Fixes \"Type instantiation is excessively deep and possibly infinite.\"\n\t\treturn handleRpcOutput(\n\t\t\tawait stub.getOrCreateAndCallRpc({\n\t\t\t\tinit: {\n\t\t\t\t\tmodule: opts.moduleName,\n\t\t\t\t\tactor: opts.actorName,\n\t\t\t\t\tinstance: opts.instanceName,\n\t\t\t\t\tinput: opts.input,\n\t\t\t\t\ttrace: opts.trace,\n\t\t\t\t},\n\t\t\t\tfn: opts.fn,\n\t\t\t\trequest: opts.request,\n\t\t\t\ttrace: opts.trace,\n\t\t\t}),\n\t\t);\n\t}\n\n\tasync actorExists(opts: ExistsOpts): Promise<boolean> {\n\t\t// TODO: Mark the actor base as destroyed\n\t\tconst stub = this.getStub(opts.moduleName, opts.actorName, opts.instanceName);\n\t\treturn await stub.initialized();\n\t}\n\n\tasync destroyActor(opts: DestroyOpts): Promise<void> {\n\t\tconst stub = this.getStub(opts.moduleName, opts.actorName, opts.instanceName);\n\t\tawait stub.destroy();\n\t}\n\n\tprivate getStub(\n\t\tmoduleName: string,\n\t\tactorName: string,\n\t\tinstanceName: string,\n\t): any {\n\t\t// TODO: Fix Deno.env.get hack. This does not return a string, it returns an object.\n\t\tconst ns = this.env.get(\"__GLOBAL_DURABLE_OBJECT\") as any;\n\n\t\tconst module = this.config.modules[moduleName]!;\n\t\tconst actor = module.actors[actorName]!;\n\t\tconst name = `%%${module.storageAlias}%%${actor.storageAlias}%%${instanceName}`;\n\t\tconst id = ns.idFromName(name);\n\n\t\treturn ns.get(id);\n\t}\n}\n\nexport { CloudflareDurableObjectsActorDriver as ActorDriver };\n",
"packages/runtime/src/actor/drivers/cloudflare_durable_objects/global_durable_object.ts":"/// <reference types=\"npm:@cloudflare/workers-types\" />\nimport { DurableObject } from \"cloudflare:workers\";\nimport { CloudflareDurableObjectsStorage } from \"./storage.ts\";\nimport { CloudflareDurableObjectsSchedule } from \"./schedule.ts\";\nimport { ActorBase } from \"../../actor.ts\";\nimport {\n\tActorContext,\n\tappendTraceEntry,\n\tConfig,\n\tEnvironment,\n\tModuleContextParams,\n\tRuntime,\n\tTrace,\n} from \"../../../mod.ts\";\nimport { RegistryCallMap } from \"../../../proxy.ts\";\nimport { ActorDriver } from \"./driver.ts\";\nimport { newTrace } from \"../../../trace.ts\";\nimport { errorToLogEntries, log } from \"../../../logger.ts\";\nimport { captureRpcOutput, RpcOutput } from \"./rpc_output.ts\";\nimport { CloudflareDurableObjectsInstance } from \"./instance.ts\";\n\nconst KEYS = {\n\tMETA: {\n\t\tMODULE: \"meta:module\",\n\t\tACTOR: \"meta:actor\",\n\t\tCREATED_AT: \"__meta:created_at\",\n\t},\n\tSCHEDULE: {\n\t\tSCHEDULE: \"schedule:schedule\",\n\t\tEVENT_PREFIX: \"schedule:event:\",\n\t\tevent(id: string): string {\n\t\t\treturn `${this.EVENT_PREFIX}${id}`;\n\t\t},\n\t},\n\tSTATE: \"state\",\n};\n\ninterface ScheduleState {\n\t// Sorted by timestamp asc\n\tevents: ScheduleIndexEvent[];\n}\n\ninterface ScheduleIndexEvent {\n\ttimestamp: number;\n\teventId: string;\n}\n\ninterface ScheduleEvent {\n\ttimestamp: number;\n\tfn: string;\n\trequest: unknown;\n}\n\n// MARK: TODO:\ninterface InitOpts {\n\tmodule: string;\n\tactor: string;\n\tinstance: string;\n\tinput: any;\n\ttrace: Trace;\n\tignoreAlreadyInitialized?: boolean;\n}\n\ninterface GetOrCreateAndCallOpts {\n\tinit: InitOpts;\n\tfn: string;\n\trequest: unknown;\n\ttrace: Trace;\n}\n\ninterface CallRpcOpts {\n\tfn: string;\n\trequest: unknown;\n\ttrace: Trace;\n}\n\n/*\n * __GlobalDurableObject type used for referencing an instance of the class.\n */\nexport interface __GlobalDurableObjectT extends DurableObject {\n\t// ALlow accessing from ActorInstanceDriver\n\treadonly publicCtx: DurableObjectState;\n\n\t// Called over network\n\tinit(opts: InitOpts): Promise<RpcOutput<void>>;\n\tinitialized(): Promise<boolean>;\n\tdestroy(): Promise<void>;\n\tgetOrCreateAndCallRpc(opts: GetOrCreateAndCallOpts): Promise<RpcOutput<any>>;\n\tcallRpc({ fn, request }: CallRpcOpts): Promise<RpcOutput<any>>;\n\n\t// Called internally\n\tscheduleEvent(timestamp: number, fn: string, request: unknown): Promise<void>;\n\talarm(): Promise<void>;\n\tget storage(): DurableObjectStorage;\n}\n\n/**\n * Actor data & config read from the actor state.\n */\ninterface ActorMeta {\n\tmoduleName: string;\n\tactorName: string;\n\tstate: any;\n}\n\n/**\n * Generate a __GlobalDurableObject class that has access to the current config.\n *\n * We have to pass the config like this since the config's import is\n * dynamically generated in entrypoint.ts.\n *\n * Doing this instead of setting a static `__GlobalDurableObject.config = xxxx`\n * is better since it ensures that you _can't_ create an instance of\n * __GlobalDurableObject that doesn't have an associated config.\n */\nexport function buildGlobalDurableObjectClass(\n\tconfig: Config,\n\tdependencyCaseConversionMap: RegistryCallMap,\n\tactorDependencyCaseConversionMap: RegistryCallMap,\n) {\n\tclass __GlobalDurableObject extends DurableObject implements __GlobalDurableObjectT {\n\t\tprivate runtime: Runtime<ModuleContextParams>;\n\n\t\tconstructor(ctx: DurableObjectState, env: unknown) {\n\t\t\tsuper(ctx, env);\n\n\t\t\tconst envAdapter: Environment = {\n\t\t\t\tget(key: string): string | undefined {\n\t\t\t\t\treturn (env as any)[key];\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tthis.runtime = new Runtime(\n\t\t\t\tenvAdapter,\n\t\t\t\tconfig,\n\t\t\t\tnew ActorDriver(envAdapter, config),\n\t\t\t\tdependencyCaseConversionMap,\n\t\t\t\tactorDependencyCaseConversionMap,\n\t\t\t);\n\t\t}\n\n\t\tget publicCtx(): DurableObjectState {\n\t\t\treturn this.ctx;\n\t\t}\n\n\t\t/**\n\t\t * Reads the metadata related to this actor from storage.\n\t\t *\n\t\t * This data is set in `init`.\n\t\t */\n\t\tasync getMeta(): Promise<ActorMeta> {\n\t\t\t// Create actor instance\n\t\t\tconst storageRes = await this.ctx.storage.get<string>([KEYS.META.MODULE, KEYS.META.ACTOR, KEYS.STATE]);\n\t\t\tconst moduleName = storageRes.get(KEYS.META.MODULE);\n\t\t\tconst actorName = storageRes.get(KEYS.META.ACTOR);\n\t\t\tconst state = storageRes.get(KEYS.STATE);\n\t\t\tif (moduleName == undefined || actorName == undefined) throw new Error(\"actor not initialized\");\n\t\t\tif (state == undefined) throw Error(\"actor state not initiated\");\n\n\t\t\treturn { moduleName, actorName, state };\n\t\t}\n\n\t\t// TODO: optimize to use in-memory state\n\t\tprivate async constructActor(context: ActorContext<ModuleContextParams>, meta: ActorMeta): Promise<ActorBase<unknown, unknown>> {\n\t\t\t// Get actor config\n\t\t\tif (!(meta.moduleName in config.modules)) throw new Error(`module not found: ${meta.moduleName}`);\n\t\t\tconst moduleConfig = config.modules[meta.moduleName]!;\n\t\t\tif (!(meta.actorName in moduleConfig.actors)) {\n\t\t\t\tthrow new Error(`actor not found: ${meta.moduleName}.${meta.actorName}`);\n\t\t\t}\n\t\t\tconst actorConfig = moduleConfig.actors[meta.actorName]!;\n\n\t\t\t// TODO: cache actor instance in memory\n\t\t\t// TODO: use ctx.waitUntil for all calls\n\t\t\t// Run actor function\n\t\t\tconst actor = await context.runBlock(async () => {\n\t\t\t\treturn new (actorConfig.actor)(\n\t\t\t\t\tnew CloudflareDurableObjectsInstance(this),\n\t\t\t\t\tnew CloudflareDurableObjectsStorage(this),\n\t\t\t\t\tnew CloudflareDurableObjectsSchedule(this),\n\t\t\t\t);\n\t\t\t});\n\n\t\t\treturn actor;\n\t\t}\n\n\t\tprivate createActorContext(moduleName: string, actorName: string, trace: Trace): ActorContext<ModuleContextParams> {\n\t\t\t// Build context\n\t\t\tconst module = config.modules[moduleName]!;\n\t\t\tconst context = new ActorContext<ModuleContextParams>(\n\t\t\t\tthis.runtime,\n\t\t\t\ttrace,\n\t\t\t\tmoduleName,\n\t\t\t\tthis.runtime.postgres.getOrCreatePrismaClient(this.runtime.env, this.runtime.config, module),\n\t\t\t\tmodule.db?.schema,\n\t\t\t\tactorName,\n\t\t\t\tdependencyCaseConversionMap,\n\t\t\t\tactorDependencyCaseConversionMap,\n\t\t\t);\n\n\t\t\treturn context;\n\t\t}\n\n\t\tasync init(opts: InitOpts): Promise<RpcOutput<void>> {\n\t\t\tconst context = this.createActorContext(\n\t\t\t\topts.module,\n\t\t\t\topts.actor,\n\t\t\t\tappendTraceEntry(opts.trace, { actorInitialize: { module: opts.module, actor: opts.actor } }),\n\t\t\t);\n\t\t\treturn await captureRpcOutput(context, async () => {\n\t\t\t\tthis.initInner(context, opts);\n\t\t\t});\n\t\t}\n\n\t\tasync initInner(context: ActorContext<ModuleContextParams>, opts: InitOpts): Promise<{ meta: ActorMeta }> {\n\t\t\t// Check if already initialized\n\t\t\tif (await this.initialized()) {\n\t\t\t\tif (!opts.ignoreAlreadyInitialized) throw new Error(\"already initialized\");\n\t\t\t}\n\n\t\t\t// Store metadata\n\t\t\tawait this.ctx.storage.put({\n\t\t\t\t[KEYS.META.MODULE]: opts.module,\n\t\t\t\t[KEYS.META.ACTOR]: opts.actor,\n\t\t\t\t[KEYS.META.CREATED_AT]: Date.now(),\n\t\t\t});\n\n\t\t\t// Build initial state\n\t\t\tconst actor = await this.constructActor(context, {\n\t\t\t\tmoduleName: opts.module,\n\t\t\t\tactorName: opts.actor,\n\t\t\t\tstate: undefined,\n\t\t\t});\n\t\t\tconst state = await context.runBlock(async () => {\n\t\t\t\tlet state = actor.initialize(context, opts.input);\n\t\t\t\tif (state instanceof Promise) state = await state;\n\t\t\t\treturn state;\n\t\t\t});\n\t\t\tawait this.ctx.storage.put(KEYS.STATE, state);\n\n\t\t\treturn {\n\t\t\t\tmeta: {\n\t\t\t\t\tmoduleName: opts.module,\n\t\t\t\t\tactorName: opts.actor,\n\t\t\t\t\tstate: state,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tasync initialized(): Promise<boolean> {\n\t\t\treturn await this.ctx.storage.get(KEYS.META.MODULE) != undefined;\n\t\t}\n\n\t\tasync destroy(): Promise<void> {\n\t\t\tawait this.ctx.storage.deleteAll();\n\t\t\tawait this.ctx.storage.deleteAlarm();\n\t\t\tawait this.ctx.storage.sync();\n\t\t}\n\n\t\tasync getOrCreateAndCallRpc(opts: GetOrCreateAndCallOpts): Promise<RpcOutput<any>> {\n\t\t\tconst context = this.createActorContext(\n\t\t\t\topts.init.module,\n\t\t\t\topts.init.actor,\n\t\t\t\tappendTraceEntry(opts.trace, { actorGetOrCreateAndCall: { module: opts.init.module, actor: opts.init.actor, fn: opts.fn } }),\n\t\t\t);\n\t\t\treturn await captureRpcOutput(context, async () => {\n\t\t\t\treturn this.getOrCreateAndCallRpcInner(context, opts);\n\t\t\t});\n\t\t}\n\n\t\tasync getOrCreateAndCallRpcInner(\n\t\t\tcontext: ActorContext<ModuleContextParams>,\n\t\t\topts: GetOrCreateAndCallOpts,\n\t\t): Promise<any> {\n\t\t\tconst { meta } = await this.initInner(context, {\n\t\t\t\t...opts.init,\n\t\t\t\tignoreAlreadyInitialized: true,\n\t\t\t});\n\n\t\t\treturn await this.callRpcInner(context, meta, { fn: opts.fn, request: opts.request, trace: opts.trace });\n\t\t}\n\n\t\tasync callRpc(opts: CallRpcOpts): Promise<RpcOutput<any>> {\n\t\t\tconst meta = await this.getMeta();\n\n\t\t\tconst context = this.createActorContext(\n\t\t\t\tmeta.moduleName,\n\t\t\t\tmeta.actorName,\n\t\t\t\tappendTraceEntry(opts.trace, { actorCall: { module: meta.moduleName, actor: meta.actorName, fn: opts.fn } }),\n\t\t\t);\n\n\t\t\treturn await captureRpcOutput(context, async () => {\n\t\t\t\treturn this.callRpcInner(context, meta, opts);\n\t\t\t});\n\t\t}\n\n\t\tasync callRpcInner(context: ActorContext<ModuleContextParams>, meta: ActorMeta, opts: CallRpcOpts): Promise<any> {\n\t\t\tconst actor = await this.constructActor(context, meta);\n\t\t\tactor.state = meta.state;\n\n\t\t\t// Call fn\n\t\t\tconst callRes = await context.runBlock(async () => {\n\t\t\t\tlet callRes = (actor as any)[opts.fn](context, opts.request)\n\t\t\t\tif (callRes instanceof Promise) callRes = await callRes;\n\t\t\t\treturn callRes;\n\t\t\t});\n\n\t\t\t// Update state\n\t\t\tawait this.ctx.storage.put(KEYS.STATE, actor.state);\n\n\t\t\treturn callRes;\n\t\t}\n\n\t\tasync scheduleEvent(timestamp: number, fn: string, request: unknown): Promise<void> {\n\t\t\t// Save event\n\t\t\tconst eventId = crypto.randomUUID();\n\t\t\tawait this.ctx.storage.put<ScheduleEvent>(KEYS.SCHEDULE.event(eventId), {\n\t\t\t\ttimestamp,\n\t\t\t\tfn,\n\t\t\t\trequest,\n\t\t\t});\n\n\t\t\t// Read index\n\t\t\tconst schedule: ScheduleState = await this.ctx.storage.get(KEYS.SCHEDULE.SCHEDULE) ?? { events: [] };\n\n\t\t\t// Insert event in to index\n\t\t\tconst newEvent: ScheduleIndexEvent = { timestamp, eventId };\n\t\t\tconst insertIndex = schedule.events.findIndex((x) => x.timestamp > newEvent.timestamp);\n\t\t\tif (insertIndex === -1) {\n\t\t\t\tschedule.events.push(newEvent);\n\t\t\t} else {\n\t\t\t\tschedule.events.splice(insertIndex, 0, newEvent);\n\t\t\t}\n\n\t\t\t// Write new index\n\t\t\tawait this.ctx.storage.put(KEYS.SCHEDULE.SCHEDULE, schedule);\n\n\t\t\t// Update alarm if:\n\t\t\t// - this is the newest event (i.e. at beginning of array) or\n\t\t\t// - this is the only event (i.e. the only event in the array)\n\t\t\tif (insertIndex == 0 || schedule.events.length == 1) {\n\t\t\t\tawait this.ctx.storage.setAlarm(newEvent.timestamp);\n\t\t\t}\n\t\t}\n\n\t\toverride async alarm(): Promise<void> {\n\t\t\tconst now = Date.now();\n\n\t\t\t// Read index\n\t\t\tconst scheduleIndex: ScheduleState = await this.ctx.storage.get(KEYS.SCHEDULE.SCHEDULE) ?? { events: [] };\n\n\t\t\t// Remove events from schedule\n\t\t\tconst runIndex = scheduleIndex.events.findIndex((x) => x.timestamp > now);\n\t\t\tconst scheduleIndexEvents = scheduleIndex.events.splice(0, runIndex + 1);\n\n\t\t\t// Find events to trigger\n\t\t\tconst eventKeys = scheduleIndexEvents.map((x) => KEYS.SCHEDULE.event(x.eventId));\n\t\t\tconst scheduleEvents = await this.ctx.storage.get<ScheduleEvent>(eventKeys);\n\t\t\tawait this.ctx.storage.delete(eventKeys);\n\n\t\t\t// Write new schedule\n\t\t\tawait this.ctx.storage.put(KEYS.SCHEDULE.SCHEDULE, scheduleIndex);\n\n\t\t\t// Set alarm for next event\n\t\t\tif (scheduleIndex.events.length > 0) {\n\t\t\t\tawait this.ctx.storage.setAlarm(scheduleIndex.events[0]!.timestamp);\n\t\t\t}\n\n\t\t\t// Iterate by event key in order to ensure we call the events in order\n\t\t\tfor (const eventKey of eventKeys) {\n\t\t\t\tconst event = scheduleEvents.get(eventKey)!;\n\t\t\t\ttry {\n\t\t\t\t\t// TODO: how do we handle this promise cleanly?\n\t\t\t\t\tconst res = this.callRpc({ fn: event.fn, request: event.request, trace: newTrace({ actorSchedule: {} }) });\n\t\t\t\t\tif (res instanceof Promise) await res;\n\t\t\t\t} catch (err) {\n\t\t\t\t\tlog(\"error\", \"failed to run scheduled event\", [\"fn\", event.fn], ...errorToLogEntries(\"error\", err));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Make storage publicly accessible for use in `StorageDriver`.\n\t\t */\n\t\tpublic get storage(): DurableObjectStorage {\n\t\t\treturn this.ctx.storage;\n\t\t}\n\t}\n\n\treturn __GlobalDurableObject;\n}\n",
"packages/runtime/src/actor/drivers/cloudflare_durable_objects/instance.ts":"import { ActorInstanceDriver } from \"../../driver.ts\";\nimport { __GlobalDurableObjectT } from \"./global_durable_object.ts\";\n\nexport class CloudflareDurableObjectsInstance implements ActorInstanceDriver {\n\tconstructor(private readonly durableObject: __GlobalDurableObjectT) {}\n\n\trunInBackground(promise: Promise<void>): void {\n\t\tthis.durableObject.publicCtx.waitUntil(promise);\n\t}\n\n\tasync forceSaveState(): Promise<void> {\n\t\t// TODO:\n\t\t// await this.durableObject.ctx.storage.put(KEYS.STATE, actor.state);\n\t\t// await this.durableObject.storage.sync();\n\t}\n\n}\n",
"packages/runtime/src/actor/drivers/cloudflare_durable_objects/rpc_output.ts":"import { LogEntry, LogLevel, logRaw } from \"../../../logger.ts\";\nimport { ActorContext, deserializeError, SerializedErrorType, serializeError, UnreachableError } from \"../../../mod.ts\";\n\n/**\n * Returned from any RPC call to a durable object.\n */\nexport interface RpcOutput<T> {\n\tresult: RpcResult<T>;\n\tlogs: [LogLevel, LogEntry[]][];\n}\n\nexport type RpcResult<T> = { ok: T } | { error: SerializedErrorType };\n\n/**\n * Capture logs & output and send it in RPC response.\n */\nexport async function captureRpcOutput<T>(ctx: ActorContext<any>, fn: () => Promise<T>): Promise<RpcOutput<T>> {\n\tlet finished = false;\n\n\t// Capture logs\n\tconst logs: [LogLevel, LogEntry[]][] = [];\n\tctx.log.addListener((level, entry) => {\n\t\tif (!finished) {\n\t\t\tlogs.push([level, entry])\n\t\t}\n\t});\n\n\t// Run function & capture logs\n\tlet result: RpcResult<T>;\n\ttry {\n\t\tconst ok = await fn();\n\t\tresult = { ok };\n\t} catch (error) {\n\t\tresult = {\n\t\t\terror: serializeError(error),\n\t\t};\n\t}\n\tfinished = true;\n\n\t// Build output\n\treturn {\n\t\tresult,\n\t\tlogs,\n\t};\n}\n\n/**\n * Re-logs & re-throws errors from an RPC call.\n */\nexport function handleRpcOutput<T>(output: RpcOutput<T>): T {\n\t// Re-log all logs that were logged on the durable object\n\t//\n\t// We do this bc we currently can't collect logs on a DO with the tail worker\n\tfor (const [logLevel, logEntries] of output.logs) {\n\t\tlogRaw(logLevel, ...logEntries);\n\t}\n\n\t// Handle result\n\tif (\"ok\" in output.result) {\n\t\treturn output.result.ok;\n\t} else if (\"error\" in output.result) {\n\t\tthrow deserializeError(output.result.error);\n\t} else {\n\t\tthrow new UnreachableError(output.result);\n\t}\n}\n",
"packages/runtime/src/actor/drivers/cloudflare_durable_objects/schedule.ts":"import { ScheduleDriver } from \"../../driver.ts\";\nimport { __GlobalDurableObjectT } from \"./global_durable_object.ts\";\n\nexport class CloudflareDurableObjectsSchedule implements ScheduleDriver {\n\tconstructor(private readonly durableObject: __GlobalDurableObjectT) {}\n\n\tafter(duration: number, fn: string, request: unknown): void {\n\t\tthis.durableObject.scheduleEvent(Date.now() + duration, fn, request);\n\t}\n\tat(timestamp: number, fn: string, request: unknown): void {\n\t\tthis.durableObject.scheduleEvent(timestamp, fn, request);\n\t}\n}\n",
"packages/runtime/src/actor/drivers/cloudflare_durable_objects/storage.ts":"import { StorageDriver } from \"../../driver.ts\";\nimport { __GlobalDurableObjectT } from \"./global_durable_object.ts\";\n\nexport class CloudflareDurableObjectsStorage implements StorageDriver {\n\tconstructor(private readonly durableObject: __GlobalDurableObjectT) {}\n\n\tasync get<V>(key: string): Promise<V | undefined> {\n\t\tconst jsonRaw = await this.durableObject.storage.get<string>(buildStorageKey(key));\n\t\tif (jsonRaw) {\n\t\t\treturn await JSON.parse(jsonRaw);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\tasync put<V>(key: string, value: V): Promise<void> {\n\t\tawait this.durableObject.storage.put(key, JSON.stringify(value));\n\t}\n\tasync delete(key: string): Promise<void> {\n\t\tawait this.durableObject.storage.delete(buildStorageKey(key));\n\t}\n}\n\n/**\n * Build a key from the actor's API that's namespaced to the storage.\n *\n * This allows us to store metadata on different keys.\n */\nfunction buildStorageKey(key: string): string {\n\treturn `storage:${key}`;\n}\n",
"packages/runtime/src/actor/drivers/memory/driver.ts":"// This file is only imported when the runtime is `deno`\n//\nimport { ModuleContextParams } from \"../../../context.ts\";\nimport { ActorContext, appendTraceEntry, Config, Environment, Runtime, Trace } from \"../../../mod.ts\";\nimport { RegistryCallMap } from \"../../../proxy.ts\";\nimport { ActorBase } from \"../../actor.ts\";\nimport { ActorDriver, CallOpts, CreateOpts, DestroyOpts, ExistsOpts, GetOrCreateAndCallOpts } from \"../../driver.ts\";\nimport { MemoryInstance } from \"./instance.ts\";\nimport { MemorySchedule } from \"./schedule.ts\";\nimport { MemoryStorage } from \"./storage.ts\";\n\nexport interface ActorRecord {\n\tmoduleName: string;\n\tactorName: string;\n\tinstanceName: string;\n\tstate?: string;\n\tstorage: Map<string, string>;\n}\n\nexport interface ActorInstance {\n\tactor: ActorBase<any, any>;\n\tcreatedAt: number;\n\taccessedAt: number;\n}\n\nexport class MemoryActorDriver implements ActorDriver {\n\tprivate runtime: Runtime<ModuleContextParams>;\n\tprivate encoder = new TextEncoder();\n\n\t/**\n\t * List of persistent actor data. This is the data that is durable and\n\t * outlives actor instances.\n\t *\n\t * Running actors are stored in `actorInstances`.\n\t */\n\tprivate actorRecords = new Map<string, ActorRecord>();\n\n\t/**\n\t * List of all actors that are currently running. These are instantiated on\n\t * demand with `getOrCreateActorInstance`.\n\t *\n\t * This is always a subset of `actorRegistry`.\n\t */\n\tprivate actorInstances = new Map<string, ActorInstance>();\n\n\tpublic constructor(\n\t\tpublic readonly env: Environment,\n\t\tpublic readonly config: Config,\n\t\tprivate dependencyCaseConversionMap: RegistryCallMap,\n\t\tprivate actorDependencyCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tthis.runtime = new Runtime(\n\t\t\tthis.env,\n\t\t\tthis.config,\n\t\t\tthis,\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t\tthis.actorDependencyCaseConversionMap,\n\t\t);\n\t}\n\n\tasync createActor({ moduleName, actorName, instanceName, input, trace }: CreateOpts): Promise<void> {\n\t\tconst id = await this.getId(moduleName, actorName, instanceName);\n\n\t\t// Ensure doesn't already exist\n\t\tif (this.actorRecords.has(await this.getId(moduleName, actorName, instanceName))) {\n\t\t\tthrow new Error(\"actor already created\");\n\t\t}\n\n\t\t// Build drivers\n\t\tconst actorRecord: ActorRecord = {\n\t\t\tmoduleName,\n\t\t\tactorName,\n\t\t\tinstanceName,\n\t\t\tstate: undefined,\n\t\t\tstorage: new Map(),\n\t\t};\n\n\t\t// TODO: cache init actor in memory\n\t\t// Run actor function\n\t\tconst { actor } = await this.getOrCreateActorInstance(actorRecord, true);\n\t\tconst context = this.createActorContext(\n\t\t\tmoduleName,\n\t\t\tactorName,\n\t\t\tappendTraceEntry(trace, { actorInitialize: { module: moduleName, actor: actorName } }),\n\t\t);\n\t\tlet initRes = actor.initialize(context, input);\n\t\tif (initRes instanceof Promise) initRes = await initRes;\n\n\t\t// Sanitize state & save state\n\t\tconst stateString = JSON.stringify(initRes);\n\t\tactor.state = JSON.parse(stateString);\n\t\tactorRecord.state = stateString;\n\n\t\t// Save actor\n\t\tthis.actorRecords.set(id, actorRecord);\n\t}\n\n\tasync callActor({ moduleName, actorName, instanceName, fn, request, trace }: CallOpts): Promise<unknown> {\n\t\tconst actorRecord = await this.getRecord(moduleName, actorName, instanceName);\n\t\tconst { actor } = await this.getOrCreateActorInstance(actorRecord, false);\n\n\t\tconst context = this.createActorContext(\n\t\t\tmoduleName,\n\t\t\tactorName,\n\t\t\tappendTraceEntry(trace, { actorCall: { module: moduleName, actor: actorName, fn } }),\n\t\t);\n\n\t\t// Run actor function\n\t\tlet callRes = (actor as any)[fn](context, request);\n\t\tif (callRes instanceof Promise) callRes = await callRes;\n\n\t\t// Sanitize state & save state\n\t\tconst stateString = JSON.stringify(actor.state);\n\t\tactor.state = JSON.parse(stateString);\n\t\tactorRecord.state = stateString;\n\n\t\treturn callRes;\n\t}\n\n\tasync getOrCreateAndCallActor(\n\t\t{ moduleName, actorName, instanceName, input, fn, request, trace }: GetOrCreateAndCallOpts,\n\t): Promise<unknown> {\n\t\t// Create actor if needed\n\t\tif (!this.actorRecords.has(await this.getId(moduleName, actorName, instanceName))) {\n\t\t\tawait this.createActor({ moduleName, actorName, instanceName, input, trace });\n\t\t}\n\n\t\t// Call actor\n\t\tconst callRes = await this.callActor({ moduleName, actorName, instanceName, fn, request, trace });\n\n\t\treturn callRes;\n\t}\n\n\tasync actorExists({ moduleName, actorName, instanceName }: ExistsOpts): Promise<boolean> {\n\t\treturn this.actorRecords.has(await this.getId(moduleName, actorName, instanceName));\n\t}\n\n\tasync destroyActor({ moduleName, actorName, instanceName }: DestroyOpts): Promise<void> {\n\t\t// TODO: Does not handle cancelling timeouts correctly\n\t\tconst id = await this.getId(moduleName, actorName, instanceName);\n\t\tthis.actorRecords.delete(id);\n\t\tif (this.actorInstances.has(id)) {\n\t\t\tthis.actorInstances.get(id)!.actor.destroyed = true;\n\t\t\tthis.actorInstances.delete(id);\n\t\t}\n\t}\n\n\tprivate async getId(moduleName: string, actorName: string, instanceName: string) {\n\t\tconst module = this.config.modules[moduleName]!;\n\t\tconst actor = module.actors[actorName]!;\n\t\tconst name = `%%${module.storageAlias}%%${actor.storageAlias}%%${instanceName}`;\n\t\treturn await this.hash(name);\n\t}\n\n\tprivate async getRecord(moduleName: string, actorName: string, instanceName: string): Promise<ActorRecord> {\n\t\tconst record = this.actorRecords.get(await this.getId(moduleName, actorName, instanceName));\n\t\tif (!record) throw new Error(\"Actor not created\");\n\t\treturn record;\n\t}\n\n\t/**\n\t * Gets a running instance or creates one on demand.\n\t *\n\t * `init` is true if calling `initialize` and `state` is undefined.\n\t */\n\tprivate async getOrCreateActorInstance(record: ActorRecord, init: boolean): Promise<ActorInstance> {\n\t\t// Create actor instance\n\t\tif (!init && record.state === undefined) throw Error(\"actor state not initiated\");\n\n\t\t// Get actor config\n\t\tif (!(record.moduleName in this.config.modules)) throw new Error(\"module not found\");\n\t\tconst moduleConfig = this.config.modules[record.moduleName]!;\n\t\tif (!(record.actorName in moduleConfig.actors)) throw new Error(\"actor not found\");\n\t\tconst actorConfig = moduleConfig.actors[record.actorName]!;\n\n\t\t// Run actor function\n\t\tconst actorId = await this.getId(record.moduleName, record.actorName, record.instanceName);\n\t\tif (this.actorInstances.has(actorId)) {\n\t\t\t// Instance exists\n\n\t\t\tconst instance = this.actorInstances.get(actorId)!;\n\t\t\tinstance.accessedAt = Date.now();\n\t\t\treturn instance;\n\t\t} else {\n\t\t\t// New instance\n\n\t\t\tconst actor = new (actorConfig.actor)(\n\t\t\t\tnew MemoryInstance(this, record),\n\t\t\t\tnew MemoryStorage(record),\n\t\t\t\tnew MemorySchedule(this, record),\n\t\t\t);\n\t\t\tactor.state = record.state ? JSON.parse(record.state!) : undefined;\n\t\t\tconst instance = {\n\t\t\t\tactor,\n\t\t\t\tcreatedAt: Date.now(),\n\t\t\t\taccessedAt: Date.now(),\n\t\t\t};\n\t\t\tthis.actorInstances.set(actorId, instance);\n\t\t\treturn instance;\n\t\t}\n\t}\n\n\tprivate createActorContext(moduleName: string, actorName: string, trace: Trace): ActorContext<ModuleContextParams> {\n\t\t// Build context\n\t\tconst module = this.config.modules[moduleName]!;\n\t\tconst context = new ActorContext<ModuleContextParams>(\n\t\t\tthis.runtime,\n\t\t\ttrace,\n\t\t\tmoduleName,\n\t\t\tthis.runtime.postgres.getOrCreatePrismaClient(this.runtime.env, this.runtime.config, module),\n\t\t\tmodule.db?.schema,\n\t\t\tactorName,\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t\tthis.actorDependencyCaseConversionMap,\n\t\t);\n\n\t\treturn context;\n\t}\n\n\tprivate async hash(input: string) {\n\t\tconst data = this.encoder.encode(input);\n\t\tconst hash = await crypto.subtle.digest(\"SHA-256\", data);\n\t\tconst hashString = Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n\n\t\treturn hashString;\n\t}\n}\n\nexport { MemoryActorDriver as ActorDriver };\n",
"packages/runtime/src/actor/drivers/memory/instance.ts":"import { ActorInstanceDriver } from \"../../driver.ts\";\nimport { ActorRecord, MemoryActorDriver } from \"./driver.ts\";\n\nexport class MemoryInstance implements ActorInstanceDriver {\n\tconstructor(private readonly driver: MemoryActorDriver, private readonly actorRecord: ActorRecord) {}\n\n\trunInBackground(_promise: Promise<void>): void {\n\t\t// No action needed\n\t}\n\n\tasync forceSaveState(): Promise<void> {\n\t\t// TODO:\n\t}\n\n}\n",
"packages/runtime/src/actor/drivers/memory/schedule.ts":"import { newTrace } from \"../../../mod.ts\";\nimport { ScheduleDriver } from \"../../driver.ts\";\nimport { ActorRecord, MemoryActorDriver } from \"./driver.ts\";\n\nexport class MemorySchedule implements ScheduleDriver {\n\tconstructor(private readonly driver: MemoryActorDriver, private readonly actorRecord: ActorRecord) {}\n\n\tafter(duration: number, fn: string, request: unknown): void {\n\t\tsetTimeout(() => {\n\t\t\tthis.driver.callActor({\n\t\t\t\tmoduleName: this.actorRecord.moduleName,\n\t\t\t\tactorName: this.actorRecord.actorName,\n\t\t\t\tinstanceName: this.actorRecord.instanceName,\n\t\t\t\tfn,\n\t\t\t\trequest,\n\t\t\t\ttrace: newTrace({ actorSchedule: {} }),\n\t\t\t});\n\t\t}, duration);\n\t}\n\n\tat(timestamp: number, fn: string, request: unknown): void {\n\t\tsetTimeout(() => {\n\t\t\tthis.driver.callActor({\n\t\t\t\tmoduleName: this.actorRecord.moduleName,\n\t\t\t\tactorName: this.actorRecord.actorName,\n\t\t\t\tinstanceName: this.actorRecord.instanceName,\n\t\t\t\tfn,\n\t\t\t\trequest,\n\t\t\t\ttrace: newTrace({ actorSchedule: {} }),\n\t\t\t});\n\t\t}, timestamp - Date.now());\n\t}\n}\n",
"packages/runtime/src/actor/drivers/memory/storage.ts":"import { StorageDriver } from \"../../driver.ts\";\nimport { ActorRecord } from \"./driver.ts\";\n\nexport class MemoryStorage implements StorageDriver {\n\tconstructor(private readonly actorRecord: ActorRecord) {}\n\n\tasync get<V>(key: string): Promise<V | undefined> {\n\t\tconst value = this.actorRecord.storage.get(key);\n\t\tif (value) return JSON.parse(value);\n\t\telse return undefined;\n\t}\n\n\tasync put<V>(key: string, value: V): Promise<void> {\n\t\tthis.actorRecord.storage.set(key, JSON.stringify(value));\n\t}\n\n\tasync delete(key: string): Promise<void> {\n\t\tthis.actorRecord.storage.delete(key);\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n}\n",
"packages/runtime/src/actor/proxy.ts":"import { Trace } from \"../mod.ts\";\nimport { ActorDriver } from \"./driver.ts\";\n\n// Returned from ctx.actors.xxx\nexport class ActorProxy {\n\tconstructor(\n\t\tprivate driver: ActorDriver,\n\t\tprivate moduleName: string,\n\t\tprivate actorName: string,\n\t\tprivate trace: Trace,\n\t) {}\n\n\tasync create<Input>(instanceName: string, input: Input): Promise<void> {\n\t\tawait this.driver.createActor({\n\t\t\tmoduleName: this.moduleName,\n\t\t\tactorName: this.actorName,\n\t\t\tinstanceName,\n\t\t\tinput,\n\t\t\ttrace: this.trace,\n\t\t});\n\t}\n\n\tasync call<Request, Response>(instanceName: string, fn: string, request: Request): Promise<Response> {\n\t\treturn await this.driver.callActor({\n\t\t\tmoduleName: this.moduleName,\n\t\t\tactorName: this.actorName,\n\t\t\tinstanceName,\n\t\t\tfn,\n\t\t\trequest,\n\t\t\ttrace: this.trace,\n\t\t}) as Response;\n\t}\n\n\tasync getOrCreateAndCall<Input, Request, Response>(\n\t\tinstanceName: string,\n\t\tinput: Input,\n\t\tfn: string,\n\t\trequest: Request,\n\t): Promise<Response> {\n\t\treturn await this.driver.getOrCreateAndCallActor({\n\t\t\tmoduleName: this.moduleName,\n\t\t\tactorName: this.actorName,\n\t\t\tinstanceName,\n\t\t\tinput,\n\t\t\tfn,\n\t\t\trequest,\n\t\t\ttrace: this.trace,\n\t\t}) as Response;\n\t}\n\n\tasync exists(instanceName: string) {\n\t\treturn await this.driver.actorExists({\n\t\t\tmoduleName: this.moduleName,\n\t\t\tactorName: this.actorName,\n\t\t\tinstanceName,\n\t\t});\n\t}\n\n\tasync destroy(instanceName: string) {\n\t\treturn await this.driver.destroyActor({\n\t\t\tmoduleName: this.moduleName,\n\t\t\tactorName: this.actorName,\n\t\t\tinstanceName,\n\t\t});\n\t}\n}\n",
"packages/runtime/src/context.ts":"import { Runtime } from \"./runtime.ts\";\nimport { Trace } from \"./trace.ts\";\nimport { RuntimeError, ValidationError } from \"./error.ts\";\nimport { appendTraceEntry } from \"./trace.ts\";\nimport { ActorProxies, buildActorRegistryProxy, buildDependencyRegistryProxy, RegistryCallMap } from \"./proxy.ts\";\nimport { DependencyScriptCallFunction } from \"./types/registry.ts\";\nimport { camelify } from \"../../case_conversion/src/mod.ts\";\nimport { buildLogEntries, errorToLogEntries, LogEntry, logRaw, spreadObjectToLogEntries } from \"./logger.ts\";\nimport { LogLevel } from \"./logger.ts\";\nimport { INTERNAL_ERROR_CODE, stringifyTrace } from \"./mod.ts\";\n\nexport interface ContextParams {\n\tdependenciesSnake: any;\n\tdependenciesCamel: any;\n\tactorsSnake: any;\n\tactorsCamel: any;\n}\n\n/**\n * Provides access to information about the runtime from a context.\n */\nexport class ContextRuntime<Params extends ContextParams> {\n\tconstructor(private readonly runtime: Runtime<Params>) {}\n\n\tpublic get publicEndpoint(): string {\n\t\treturn this.runtime.publicEndpoint;\n\t}\n}\n\nexport class Context<Params extends ContextParams> {\n\tpublic readonly log: ContextLog<Params>;\n\n\tpublic get runtime(): ContextRuntime<Params> {\n\t\treturn new ContextRuntime(this.internalRuntime);\n\t}\n\n\tpublic constructor(\n\t\tprotected readonly internalRuntime: Runtime<Params>,\n\t\tpublic readonly trace: Trace,\n\t\tprivate readonly dependencyCaseConversionMap: RegistryCallMap,\n\t\tprotected readonly actorCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tthis.log = new ContextLog(this);\n\t}\n\n\tprotected getRouteContext(moduleName: string, routeName: string) {\n\t\tconst module = this.internalRuntime.config.modules[moduleName];\n\t\tif (!module) throw new Error(`Module not found: ${moduleName}`);\n\n\t\tconst route = module.routes[routeName];\n\t\tif (!route) throw new Error(`Route not found: ${routeName}`);\n\n\t\treturn new RouteContext(\n\t\t\tthis.internalRuntime,\n\t\t\tappendTraceEntry(this.trace, {\n\t\t\t\troute: { module: moduleName, route: routeName },\n\t\t\t}),\n\t\t\tmoduleName,\n\t\t\tthis.internalRuntime.postgres.getOrCreatePrismaClient(\n\t\t\t\tthis.internalRuntime.env,\n\t\t\t\tthis.internalRuntime.config,\n\t\t\t\tmodule,\n\t\t\t),\n\t\t\tmodule.db?.schema,\n\t\t\trouteName,\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t\tthis.actorCaseConversionMap,\n\t\t);\n\t}\n\n\tprotected isAllowedModuleName(_moduleName: string): boolean {\n\t\treturn true;\n\t}\n\n\tpublic call: DependencyScriptCallFunction<this, Params[\"dependenciesSnake\"]> = async function (\n\t\tmoduleName,\n\t\tscriptName,\n\t\treq,\n\t) {\n\t\t// Check if calling module is allowed to call target module\n\t\tif (!this.isAllowedModuleName(moduleName)) {\n\t\t\tthrow new RuntimeError(\n\t\t\t\t\"CANNOT_ACCESS_MODULE\",\n\t\t\t\t{ cause: `Module \\`${moduleName}\\` is not a dependency` },\n\t\t\t);\n\t\t}\n\n\t\t// Lookup module\n\t\tconst module = this.internalRuntime.config.modules[moduleName]!;\n\t\tif (!module) throw new Error(`Module not found: ${moduleName}`);\n\n\t\t// Lookup script\n\t\tconst script = module.scripts[scriptName];\n\t\tif (!script) throw new Error(`Script not found: ${scriptName}`);\n\n\t\t// Build context\n\t\tconst ctx = new ScriptContext(\n\t\t\tthis.internalRuntime,\n\t\t\tappendTraceEntry(this.trace, {\n\t\t\t\tscript: { module: moduleName, script: scriptName },\n\t\t\t}),\n\t\t\tmoduleName,\n\t\t\tthis.internalRuntime.postgres.getOrCreatePrismaClient(\n\t\t\t\tthis.internalRuntime.env,\n\t\t\t\tthis.internalRuntime.config,\n\t\t\t\tmodule,\n\t\t\t),\n\t\t\tmodule.db?.schema,\n\t\t\tscriptName,\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t\tthis.actorCaseConversionMap,\n\t\t);\n\t\tctx.log._listeners.push(...this.log._listeners);\n\n\t\tconst requestParseResult = await script.requestSchema.safeParseAsync(req);\n\t\tif (!requestParseResult.success) {\n\t\t\tthrow new ValidationError(\"Request did not match schema.\", requestParseResult.error);\n\t\t}\n\n\t\tconst request = requestParseResult.data;\n\n\t\t// Log start\n\t\tconst scriptStart = performance.now();\n\t\tctx.log.debug(\"script request\", ...spreadObjectToLogEntries(\"request\", request));\n\n\t\t// Execute script\n\t\tconst duration = Math.ceil(performance.now() - scriptStart);\n\t\tconst res = await ctx.runBlock(async () => await script.run(ctx, request));\n\n\t\t// Log finish\n\t\t//\n\t\t// `duration` will be 0 on Cloudflare Workers if there are no async\n\t\t// actions performed inside of the request:\n\t\t// https://developers.cloudflare.com/workers/runtime-apis/performance/\n\t\tctx.log.debug(\n\t\t\t\"script response\",\n\t\t\t...(duration > 0 ? [[\"duration\", `${duration}ms`] as LogEntry] : []),\n\t\t\t...spreadObjectToLogEntries(\"response\", res),\n\t\t);\n\n\t\tconst responseParseResult = await script.responseSchema.safeParseAsync<typeof res>(res);\n\t\tif (!responseParseResult.success) {\n\t\t\tthrow new ValidationError(\n\t\t\t\t\"Response did not match schema. If you are the module author, check the response type.\",\n\t\t\t\tresponseParseResult.error,\n\t\t\t);\n\t\t}\n\t\treturn responseParseResult.data;\n\t}\n\n\tpublic get modules() {\n\t\treturn buildDependencyRegistryProxy<Params>(\n\t\t\tthis,\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t);\n\t}\n\n\tpublic async tryCallRaw(\n\t\tmoduleName: string,\n\t\tscriptName: string,\n\t\treq: unknown,\n\t): Promise<object | null> {\n\t\t// Lookup module\n\t\tconst module = this.internalRuntime.config.modules[moduleName];\n\t\tif (!module) return null;\n\n\t\t// Lookup script\n\t\tconst script = module.scripts[scriptName];\n\t\tif (!script) return null;\n\n\t\treturn await this.call(moduleName as any, scriptName as any, req as any);\n\t}\n\n\tpublic async canCall(\n\t\tmoduleName: string,\n\t\tscriptName: string,\n\t\treq?: unknown,\n\t): Promise<boolean> {\n\t\t// Lookup module\n\t\tconst module = this.internalRuntime.config.modules[moduleName];\n\t\tif (!module) return false;\n\n\t\t// Lookup script\n\t\tconst script = module.scripts[scriptName];\n\t\tif (!script) return false;\n\n\t\tconst result = await script.requestSchema.safeParseAsync(req);\n\t\tif (!result.success) return false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Runs a block of code and catches any related errors. Errors thrown from\n\t * this block will be enriched or replaced with an INTERNAL_ERROR.\n\t */\n\tpublic async runBlock<Res>(fn: () => Promise<Res>): Promise<Res> {\n\t\ttry {\n\t\t\treturn await fn();\n\t\t} catch (cause) {\n\t\t\tif (cause instanceof RuntimeError) {\n\t\t\t\t// Enrich error with more context\n\t\t\t\tcause.enrich(this.internalRuntime, this);\n\t\t\t\tthrow cause;\n\t\t\t} else {\n\t\t\t\t// Convert to RuntimeError\n\t\t\t\tconst error = new RuntimeError(INTERNAL_ERROR_CODE, { cause });\n\t\t\t\terror.enrich(this.internalRuntime, this);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport type LogListener = (level: LogLevel, entries: LogEntry[]) => void;\n\nclass ContextLog<Params extends ContextParams> {\n\tpublic _listeners: LogListener[] = [];\n\n\tconstructor(private readonly context: Context<Params>) {}\n\n\tpublic addListener(listener: LogListener) {\n\t\tthis._listeners.push(listener);\n\t}\n\n\tprivate log(level: LogLevel, message: string, ...data: LogEntry[]) {\n\t\t// Build entries\n\t\tconst logEntries = buildLogEntries(\n\t\t\tlevel,\n\t\t\tmessage,\n\t\t\t[\"trace\", stringifyTrace(this.context.trace)],\n\t\t\t...data,\n\t\t);\n\n\t\t// Capture logs\n\t\tfor (const listener of this._listeners) {\n\t\t\tlistener(level, logEntries);\n\t\t}\n\n\t\t// Output\n\t\tlogRaw(level, ...logEntries);\n\t}\n\n\tpublic error(message: string, ...data: LogEntry[]) {\n\t\tthis.log(\"error\", message, ...data);\n\t}\n\n\tpublic warn(message: string, ...data: LogEntry[]) {\n\t\tthis.log(\"warn\", message, ...data);\n\t}\n\n\tpublic info(message: string, ...data: LogEntry[]) {\n\t\tthis.log(\"info\", message, ...data);\n\t}\n\n\tpublic debug(message: string, ...data: LogEntry[]) {\n\t\tthis.log(\"debug\", message, ...data);\n\t}\n\n\tpublic trace(message: string, ...data: LogEntry[]) {\n\t\tthis.log(\"trace\", message, ...data);\n\t}\n}\n\nexport interface ModuleContextParams extends ContextParams {\n\tactorsSnake: any;\n\tactorsCamel: any;\n\tuserConfig: any;\n\tdatabase: any;\n\tdatabaseSchema: any;\n}\n\n/**\n * Context for a module.\n */\nexport class ModuleContext<Params extends ModuleContextParams> extends Context<Params> {\n\tpublic constructor(\n\t\truntime: Runtime<Params>,\n\t\ttrace: Trace,\n\t\tpublic readonly moduleName: string,\n\t\tpublic readonly db: Params[\"database\"],\n\t\tpublic readonly dbSchema: Params[\"databaseSchema\"],\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t\tactorCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tsuper(runtime, trace, dependencyCaseConversionMap, actorCaseConversionMap);\n\t}\n\n\tprotected override isAllowedModuleName(targetModuleName: string): boolean {\n\t\treturn this.internalRuntime.config\n\t\t\t.modules[this.moduleName]\n\t\t\t?.dependencies\n\t\t\t.has(targetModuleName) ?? false;\n\t}\n\n\tpublic get config(): Params[\"userConfig\"] {\n\t\treturn this.internalRuntime.config.modules[this.moduleName]!.userConfig as Params[\"userConfig\"];\n\t}\n\n\tpublic get actors(): ActorProxies<Params[\"actorsCamel\"]> {\n\t\treturn buildActorRegistryProxy<Params[\"actorsSnake\"], Params[\"actorsCamel\"]>(\n\t\t\tthis.internalRuntime,\n\t\t\t// TODO: Find a better way of looking up the module name. We don't use\n\t\t\t// camel -> snake conversions anymore for modules in actors.\n\t\t\tthis.actorCaseConversionMap[camelify(this.moduleName)]!,\n\t\t\tthis.trace,\n\t\t);\n\t}\n}\n\n/**\n * Context for a script.\n */\nexport class ScriptContext<Params extends ModuleContextParams> extends ModuleContext<Params> {\n\tpublic constructor(\n\t\truntime: Runtime<Params>,\n\t\ttrace: Trace,\n\t\tmoduleName: string,\n\t\tdb: Params[\"database\"],\n\t\tdbSchema: Params[\"databaseSchema\"],\n\t\tpublic readonly scriptName: string,\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t\tactorCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tsuper(runtime, trace, moduleName, db, dbSchema, dependencyCaseConversionMap, actorCaseConversionMap);\n\t}\n}\n\n/**\n * Context for an actor.\n */\nexport class ActorContext<Params extends ModuleContextParams> extends ModuleContext<Params> {\n\tpublic constructor(\n\t\truntime: Runtime<Params>,\n\t\ttrace: Trace,\n\t\tmoduleName: string,\n\t\tdb: Params[\"database\"],\n\t\tdbSchema: Params[\"databaseSchema\"],\n\t\tpublic readonly actorName: string,\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t\tactorCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tsuper(runtime, trace, moduleName, db, dbSchema, dependencyCaseConversionMap, actorCaseConversionMap);\n\t}\n}\n\n/**\n * Context for a route.\n */\nexport class RouteContext<Params extends ModuleContextParams> extends ModuleContext<Params> {\n\tpublic constructor(\n\t\truntime: Runtime<Params>,\n\t\ttrace: Trace,\n\t\tmoduleName: string,\n\t\tdb: Params[\"database\"],\n\t\tdbSchema: Params[\"databaseSchema\"],\n\t\tpublic readonly routeName: string,\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t\tactorCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tsuper(runtime, trace, moduleName, db, dbSchema, dependencyCaseConversionMap, actorCaseConversionMap);\n\t}\n\n\tpublic static fromContext<Params extends ModuleContextParams>(\n\t\tctx: Context<Params>,\n\t\tmoduleName: string,\n\t\trouteName: string,\n\t): RouteContext<Params> {\n\t\t// FIXME: This is a pretty terrible hack. We should find a better way to\n\t\t// do this, probably with a \"public\" underscore function.\n\t\tconst ctxWithPublicGRC = ctx as unknown as { getRouteContext: Context<Params>[\"getRouteContext\"] };\n\t\treturn ctxWithPublicGRC.getRouteContext(moduleName, routeName);\n\t}\n}\n\n/**\n * Context for a test.\n */\nexport class TestContext<Params extends ModuleContextParams> extends ModuleContext<Params> {}\n",
"packages/runtime/src/deps.ts":"export { assertEquals, assertExists } from \"https://deno.land/std@0.208.0/assert/mod.ts\";\nexport { fromError as fromValidationError, isZodErrorLike as isValidationError } from \"npm:zod-validation-error@3.3.0\";\n",
"packages/runtime/src/environment.ts":"export interface Environment {\n\tget(key: string): string | undefined;\n}\n",
"packages/runtime/src/error.ts":"import { assert } from \"https://deno.land/std@0.208.0/assert/mod.ts\";\nimport { ModuleContext } from \"./context.ts\";\nimport { Context } from \"./context.ts\";\nimport { fromValidationError } from \"./deps.ts\";\nimport { ModuleContextParams } from \"./mod.ts\";\nimport { ErrorConfig, Runtime } from \"./runtime.ts\";\nimport { Trace } from \"./trace.ts\";\n\nexport const INTERNAL_ERROR_CODE = \"internal_error\";\nexport const INTERNAL_ERROR_DESCRIPTION = \"Internal error. Read the backend logs for more details.\";\n\nconst DEFAULT_ERROR_CONFIGS: Record<string, ErrorConfig> = {\n\t[INTERNAL_ERROR_CODE]: {\n\t\tdescription: INTERNAL_ERROR_DESCRIPTION,\n\t},\n\t\"unreachable\": {\n\t\tdescription: \"Unreachable.\",\n\t},\n\t\"validation\": {\n\t\tdescription: \"The provided data does not match the required schema.\"\n\t},\n}\n\n// MARK: Runtime Error\nexport interface RuntimeErrorOptions extends ErrorOptions {\n\tinternal?: boolean,\n\tmeta?: any;\n\tstatusCode?: number;\n}\n\nexport class RuntimeError extends Error {\n\tpublic moduleName?: string;\n\tpublic trace?: Trace;\n\tpublic errorConfig?: ErrorConfig;\n\tpublic internal: boolean;\n\tpublic meta?: any;\n\tpublic statusCode: number;\n\n\tpublic constructor(\n\t\tpublic readonly code: string,\n\t\toptions?: RuntimeErrorOptions,\n\t) {\n\t\tsuper(code, options);\n\t\tthis.internal = options?.internal ?? false;\n\t\tthis.meta = options?.meta;\n\t\tthis.statusCode = options?.statusCode ?? 500;\n\t}\n\n\tpublic enrich<\n\t\tParams extends ModuleContextParams,\n\t\tCtx extends Context<Params>,\n\t>(\n\t\truntime: Runtime<Params>,\n\t\tcontext: Ctx,\n\t) {\n\t\t// Add context to error\n\t\tif (context instanceof ModuleContext) {\n\t\t\tthis.moduleName = context.moduleName;\n\t\t}\n\t\tif (!this.trace) {\n\t\t\tthis.trace = context.trace;\n\t\t}\n\n\t\t// Lookup error config if doesn't already exist\n\t\tif (!this.errorConfig && this.moduleName) {\n\t\t\tif (this.code in DEFAULT_ERROR_CONFIGS) {\n\t\t\t\tthis.errorConfig = DEFAULT_ERROR_CONFIGS[this.code];\n\t\t\t\tthis.message = `${this.moduleName}[${this.code}]: ${this.errorConfig!.description}`;\n\t\t\t} else {\n\t\t\t\tconst errorConfig = runtime.config.modules[this.moduleName]?.errors[this.code];\n\t\t\t\tif (errorConfig) {\n\t\t\t\t\tthis.errorConfig = errorConfig;\n\t\t\t\t\tif (errorConfig.description) {\n\t\t\t\t\t\tthis.message = `${this.moduleName}[${this.code}]: ${errorConfig.description}`;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontext.log.warn(\n\t\t\t\t\t\t\"error config not found. if you are the module author, check the error exists in module.json.\",\n\t\t\t\t\t\t[\"errorCode\", this.code],\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build enriched message\n\t\tlet message = \"\";\n\t\tif (this.moduleName) {\n\t\t\tmessage += `${this.moduleName}[${this.code}]`;\n\t\t} else {\n\t\t\tmessage += this.code;\n\t\t}\n\t\tif (this.errorConfig?.description) {\n\t\t\tmessage += `: ${this.errorConfig.description}`;\n\t\t}\n\t\tthis.message = message;\n\t}\n\n\tpublic serialize(): SerializedErrorType {\n\t\treturn {\n\t\t\tRuntimeError: {\n\t\t\t\tname: this.name,\n\t\t\t\tmessage: this.message,\n\t\t\t\tstack: this.stack,\n\t\t\t\tcause: this.cause ? serializeError(this.cause) : undefined,\n\t\t\t\tcode: this.code,\n\t\t\t\tmoduleName: this.moduleName,\n\t\t\t\ttrace: this.trace,\n\t\t\t\terrorConfig: this.errorConfig,\n\t\t\t\tmeta: this.meta,\n\t\t\t\tstatusCode: this.statusCode,\n\t\t\t},\n\t\t};\n\t}\n\n\tpublic static deserialize(data: RuntimeErrorSerialized, intermediateError?: RuntimeError): RuntimeError {\n\t\t// Get or create error\n\t\tconst error = intermediateError ?? new RuntimeError(data.code, {\n\t\t\tmeta: data.meta,\n\t\t\tstatusCode: data.statusCode,\n\t\t});\n\n\t\t// This data is set in the constructor of the intermediate error\n\t\tif (intermediateError === undefined) {\n\t\t\terror.name = data.name;\n\t\t\terror.message = data.message;\n\t\t}\n\n\t\t// Overwrite common properties\n\t\terror.stack = data.stack;\n\t\tif (data.cause) {\n\t\t\terror.cause = deserializeError(data.cause);\n\t\t}\n\n\t\t// Assign RuntimeError-specific properties\n\t\terror.moduleName = data.moduleName;\n\t\terror.trace = data.trace;\n\t\terror.errorConfig = data.errorConfig;\n\n\t\treturn error;\n\t}\n}\n\nexport interface RuntimeErrorSerialized extends ErrorSerialized {\n\tcode: string;\n\tmoduleName?: string;\n\ttrace?: Trace;\n\terrorConfig?: ErrorConfig;\n\tmeta?: any;\n\tstatusCode: number;\n}\n\n// MARK: Unreachable Error\nexport class UnreachableError extends RuntimeError {\n\tconstructor(public readonly value: never) {\n\t\tsuper(\"unreachable\", { internal: true, meta: { value } });\n\t}\n\n\tpublic override serialize(): SerializedErrorType {\n\t\tconst baseData = super.serialize();\n\t\tassert(\"RuntimeError\" in baseData);\n\t\tconst serialized: UnreachableErrorSerialized = {\n\t\t\t...baseData.RuntimeError,\n\t\t\tvalue: this.value,\n\t\t};\n\t\treturn { UnreachableError: serialized };\n\t}\n\n\tpublic static override deserialize(data: UnreachableErrorSerialized): UnreachableError {\n\t\tconst error = new UnreachableError(data.value);\n\t\tRuntimeError.deserialize(data, error);\n\t\treturn error;\n\t}\n}\n\nexport interface UnreachableErrorSerialized extends RuntimeErrorSerialized {\n\tvalue: never;\n}\n\n// MARK: Validation Error\nexport class ValidationError extends RuntimeError {\n\tconstructor(message: string, public validationError: any) {\n\t\tsuper(\"validation\", {\n\t\t\tmeta: {\n\t\t\t\terror: { ...validationError, name: \"ValidationError\" },\n\t\t\t},\n\t\t});\n\t\tthis.cause = `${message} ${fromValidationError(validationError).toString()}`;\n\t}\n\n\tpublic override serialize(): SerializedErrorType {\n\t\tconst baseData = super.serialize();\n\t\tassert(\"RuntimeError\" in baseData);\n\t\tconst serialized: ValidationErrorSerialized = {\n\t\t\t...baseData.RuntimeError,\n\t\t\tvalidationError: this.validationError,\n\t\t};\n\t\treturn { ValidationError: serialized };\n\t}\n\n\tpublic static override deserialize(data: ValidationErrorSerialized): ValidationError {\n\t\tconst error = new ValidationError(data.message, data.validationError);\n\t\tRuntimeError.deserialize(data, error);\n\t\treturn error;\n\t}\n}\n\nexport interface ValidationErrorSerialized extends RuntimeErrorSerialized {\n\tvalidationError: any;\n}\n\n// MARK: Serialize\nexport type SerializedErrorType =\n\t| { Error: ErrorSerialized }\n\t| { RuntimeError: RuntimeErrorSerialized }\n\t| { UnreachableError: UnreachableErrorSerialized }\n\t| { ValidationError: ValidationErrorSerialized };\n\nexport interface ErrorSerialized {\n\tname: string;\n\tmessage: string;\n\tstack?: string;\n\tcause?: SerializedErrorType;\n}\n\nexport function serializeError(error: unknown): SerializedErrorType {\n\tif (error instanceof RuntimeError) {\n\t\treturn error.serialize();\n\t} else if (error instanceof Error) {\n\t\treturn {\n\t\t\tError: {\n\t\t\t\tname: error.name,\n\t\t\t\tmessage: error.message,\n\t\t\t\tstack: error.stack,\n\t\t\t\tcause: error.cause ? serializeError(error.cause) : undefined,\n\t\t\t},\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\tError: {\n\t\t\t\tname: \"Error\",\n\t\t\t\tmessage: `${error}`,\n\t\t\t},\n\t\t};\n\t}\n}\n\nexport function deserializeError(data: SerializedErrorType): Error {\n\tif (\"UnreachableError\" in data) {\n\t\treturn UnreachableError.deserialize(data.UnreachableError);\n\t} else if (\"ValidationError\" in data) {\n\t\treturn ValidationError.deserialize(data.ValidationError);\n\t} else if (\"RuntimeError\" in data) {\n\t\treturn RuntimeError.deserialize(data.RuntimeError);\n\t} else if (\"Error\" in data) {\n\t\tconst error = new Error(data.Error.message);\n\t\terror.name = data.Error.name;\n\t\terror.stack = data.Error.stack;\n\t\tif (data.Error.cause) {\n\t\t\terror.cause = deserializeError(data.Error.cause);\n\t\t}\n\t\treturn error;\n\t} else {\n\t\tthrow new Error(\"Unknown error type\");\n\t}\n}\n",
"packages/runtime/src/error_test.ts":"import { unimplemented } from \"https://deno.land/std@0.208.0/assert/unimplemented.ts\";\nimport { assertEquals, assertExists } from \"./deps.ts\";\nimport { ModuleContext } from \"./context.ts\";\nimport { RuntimeError } from \"./error.ts\";\nimport { BuildRuntime, ModuleContextParams, newTrace } from \"./mod.ts\";\nimport { Runtime } from \"./runtime.ts\";\nimport { ActorDriver, CallOpts, CreateOpts, DestroyOpts, ExistsOpts, GetOrCreateAndCallOpts } from \"./actor/driver.ts\";\n\ninterface Params extends ModuleContextParams {\n\tdependenciesSnake: { test_module: Record<string, never> };\n\tdependenciesCamel: { testModule: Record<string, never> };\n\tactorsSnake: Record<never, never>;\n\tactorsCamel: Record<never, never>;\n\tuserConfig: null;\n\tdatabase: undefined;\n\tdatabaseSchema: undefined;\n}\n\nclass DummyActorDriver implements ActorDriver {\n\tcreateActor(_opts: CreateOpts): Promise<void> {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\tcallActor(_opts: CallOpts): Promise<unknown> {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\tgetOrCreateAndCallActor(_opts: GetOrCreateAndCallOpts): Promise<unknown> {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\tactorExists(_opts: ExistsOpts): Promise<boolean> {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\tdestroyActor(_opts: DestroyOpts): Promise<void> {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n}\n\nDeno.test(\"error\", async () => {\n\tconst dependencyCaseConversionMap = {\n\t\ttestModule: {},\n\t} as const;\n\tconst actorCaseConversionMap = {} as const;\n\n\t// Setup\n\tconst runtime = new Runtime<Params>(\n\t\tDeno.env,\n\t\t{\n\t\t\truntime: BuildRuntime.Deno,\n\t\t\tmodules: {\n\t\t\t\ttest_module: {\n\t\t\t\t\tstorageAlias: \"test_module\",\n\t\t\t\t\tscripts: {},\n\t\t\t\t\troutes: {},\n\t\t\t\t\tactors: {},\n\t\t\t\t\terrors: {\n\t\t\t\t\t\t\"TEST_ERROR\": {},\n\t\t\t\t\t},\n\t\t\t\t\tdependencies: new Set([\"test_module\"]),\n\t\t\t\t\tuserConfig: null,\n\t\t\t\t},\n\t\t\t},\n\t\t\tdb: {\n\t\t\t\tcreatePgPool: () => unimplemented(),\n\t\t\t},\n\t\t},\n\t\tnew DummyActorDriver(),\n\t\tdependencyCaseConversionMap,\n\t\tactorCaseConversionMap,\n\t);\n\n\tconst moduleContext = new ModuleContext<Params>(\n\t\truntime,\n\t\tnewTrace({ internalTest: {} }),\n\t\t\"test_module\",\n\t\tundefined,\n\t\tundefined,\n\t\tdependencyCaseConversionMap,\n\t\tactorCaseConversionMap,\n\t);\n\n\t// Create error\n\tconst error = new RuntimeError(\"TEST_ERROR\");\n\tassertEquals(error.message.split(\"\\n\")[0], \"TEST_ERROR\");\n\n\t// Erich error\n\terror.enrich(runtime, moduleContext);\n\tassertExists(error.moduleName);\n\tassertExists(error.trace);\n\tassertExists(error.errorConfig);\n\tassertEquals(error.message.split(\"\\n\")[0], \"test_module[TEST_ERROR]\");\n});\n",
"packages/runtime/src/logger.ts":"import { RuntimeError } from \"./error.ts\";\nimport { stringifyTrace } from \"./mod.ts\";\n\nexport type LogLevel = \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\";\n\nexport type LogEntry = [string, LogValue];\nexport type LogValue = string | number | boolean | null | undefined;\n\nconst LOG_LEVEL_COLORS: Record<LogLevel, string> = {\n\terror: \"\\x1b[31m\", // Red\n\twarn: \"\\x1b[33m\", // Yellow\n\tinfo: \"\\x1b[32m\", // Green\n\tdebug: \"\\x1b[36m\", // Cyan\n\ttrace: \"\\x1b[35m\", // Magenta\n};\n\nconst RESET_COLOR = \"\\x1b[0m\";\n\n/** Builds the full entries for a log. */\nexport function buildLogEntries(level: LogLevel, message: string, ...data: LogEntry[]): LogEntry[] {\n\treturn [\n\t\t[\"ts\", getFormattedTimestamp()],\n\t\t[\"level\", level],\n\t\t[\"msg\", message],\n\t\t...data,\n\t];\n}\n\nexport function log(level: LogLevel, message: string, ...data: LogEntry[]) {\n\tlogRaw(\n\t\tlevel,\n\t\t...buildLogEntries(level, message, ...data),\n\t);\n}\n\nexport function logRaw(level: LogLevel, ...data: any[]) {\n\tlet message = stringify(...data);\n\n\tif (LOGGER_CONFIG.enableColor) {\n\t\tmessage = `${LOG_LEVEL_COLORS[level]}${message}${RESET_COLOR}`;\n\t}\n\n\toriginalConsole.log(message);\n}\n\n/**\n * Serializes logfmt line using orderer parameters.\n *\n * We use varargs because it's ordered & it has less overhead than an object.\n *\n * ## Styling Methodology\n *\n * The three things you need to know for every log line is the level, the\n * message, and who called it. These properties are highlighted in different colros\n * and sorted in th eorder that you usually read them.\n *\n * Once you've found a log line you care about, then you want to find the\n * property you need to see. The property names are bolded and the default color\n * while the rest of the data is dim. This lets you scan to find the property\n * name quickly then look closer to read the data associated with the\n * property.\n */\nexport function stringify(...data: LogEntry[]) {\n\tlet line = \"\";\n\n\tfor (let i = 0; i < data.length; i++) {\n\t\tconst [key, valueRaw] = data[i]!;\n\n\t\tlet isNull = false;\n\t\tlet valueString: string;\n\t\tif (valueRaw == null) {\n\t\t\tisNull = true;\n\t\t\tvalueString = \"\";\n\t\t} else {\n\t\t\tvalueString = valueRaw.toString();\n\t\t}\n\n\t\tconst needsQuoting = valueString.indexOf(\" \") > -1 || valueString.indexOf(\"=\") > -1;\n\t\tconst needsEscaping = valueString.indexOf('\"') > -1 || valueString.indexOf(\"\\\\\") > -1;\n\n\t\tif (needsEscaping) valueString = valueString.replace(/[\"\\\\]/g, \"\\\\$&\");\n\t\tif (needsQuoting || needsEscaping) valueString = '\"' + valueString + '\"';\n\t\tif (valueString === \"\" && !isNull) valueString = '\"\"';\n\n\t\tif (LOGGER_CONFIG.enableColor) {\n\t\t\t// With color\n\n\t\t\t// Secial message colors\n\t\t\tlet color = \"\\x1b[2m\";\n\t\t\tif (key == \"level\" && valueString in LOG_LEVEL_COLORS) {\n\t\t\t\tcolor = LOG_LEVEL_COLORS[valueString as LogLevel];\n\t\t\t} else if (key == \"msg\") {\n\t\t\t\tcolor = \"\\x1b[32m\";\n\t\t\t} else if (key == \"trace\") {\n\t\t\t\tcolor = \"\\x1b[34m\";\n\t\t\t}\n\n\t\t\t// Format line\n\t\t\tline += \"\\x1b[0m\\x1b[1m\" + key + \"\\x1b[0m\" + \"\\x1b[2m=\\x1b[0m\" + color + valueString + RESET_COLOR;\n\t\t} else {\n\t\t\t// No color\n\t\t\tline += key + \"=\" + valueString;\n\t\t}\n\n\t\tif (i != data.length - 1) {\n\t\t\tline += \" \";\n\t\t}\n\t}\n\n\treturn line;\n}\n\nexport function getFormattedTimestamp() {\n\tconst now = new Date();\n\n\tconst year = now.getUTCFullYear();\n\tconst month = String(now.getUTCMonth() + 1).padStart(2, \"0\");\n\tconst day = String(now.getUTCDate()).padStart(2, \"0\");\n\tconst hours = String(now.getUTCHours()).padStart(2, \"0\");\n\tconst minutes = String(now.getUTCMinutes()).padStart(2, \"0\");\n\tconst seconds = String(now.getUTCSeconds()).padStart(2, \"0\");\n\tconst milliseconds = String(now.getUTCMilliseconds()).padStart(3, \"0\");\n\n\treturn `${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${milliseconds}Z`;\n}\n\nfunction castToLogValue(v: unknown): LogValue {\n\tif (typeof v === \"string\" || typeof v === \"number\" || typeof v === \"boolean\" || v === null || v === undefined) {\n\t\treturn v;\n\t}\n\treturn JSON.stringify(v);\n}\n\n// Patch console methods\nconst originalConsole = { ...console };\n\nfunction consoleLogWrapper(level: LogLevel, ...args: unknown[]) {\n\tconst data: LogEntry[] = args.slice(1).map((v, i) => [`data${i}`, castToLogValue(v)]);\n\tlog(level, args[0] as string, ...data);\n}\n\nconsole.error = consoleLogWrapper.bind(undefined, \"error\");\nconsole.warn = consoleLogWrapper.bind(undefined, \"warn\");\nconsole.info = consoleLogWrapper.bind(undefined, \"info\");\nconsole.log = consoleLogWrapper.bind(undefined, \"info\");\nconsole.debug = consoleLogWrapper.bind(undefined, \"debug\");\nconsole.trace = consoleLogWrapper.bind(undefined, \"trace\");\n\n// MARK: Config\ninterface GlobalLoggerConfig {\n\tenableColor: boolean;\n\tenableSpreadObject: boolean;\n}\n\nexport const LOGGER_CONFIG: GlobalLoggerConfig = {\n\tenableColor: false,\n\tenableSpreadObject: false,\n};\n\n// MARK: Utils\n/**\n * Converts an object in to an easier to read KV of entries.\n */\nexport function spreadObjectToLogEntries(base: string, data: unknown): LogEntry[] {\n\tif (\n\t\tLOGGER_CONFIG.enableSpreadObject && typeof data == \"object\" && !Array.isArray(data) && data !== null &&\n\t\tObject.keys(data).length != 0 && Object.keys(data).length < 16\n\t) {\n\t\tconst logData: LogEntry[] = [];\n\t\tfor (const key in data) {\n\t\t\t// logData.push([`${base}.${key}`, JSON.stringify((data as any)[key])]);\n\t\t\tlogData.push(...spreadObjectToLogEntries(`${base}.${key}`, (data as any)[key]));\n\t\t}\n\t\treturn logData;\n\t} else {\n\t\treturn [[base, JSON.stringify(data)]];\n\t}\n}\n\nexport function errorToLogEntries(base: string, error: unknown): LogEntry[] {\n\tif (error instanceof RuntimeError) {\n\t\treturn [\n\t\t\t[`${base}.code`, error.code],\n\t\t\t[`${base}.description`, error.errorConfig?.description],\n\t\t\t[`${base}.module`, error.moduleName],\n\t\t\t...(error.trace ? [[`${base}.trace`, stringifyTrace(error.trace)] as LogEntry] : []),\n\t\t\t...(error.stack ? [[`${base}.stack`, formatStackTrace(error.stack)] as LogEntry] : []),\n\t\t\t...(error.meta ? [[`${base}.meta`, JSON.stringify(error.meta)] as LogEntry] : []),\n\t\t\t...(error.cause instanceof Error ? errorToLogEntries(`${base}.cause`, error.cause) : []),\n\t\t];\n\t} else if (error instanceof Error) {\n\t\treturn [\n\t\t\t[`${base}.name`, error.name],\n\t\t\t[`${base}.message`, error.message],\n\t\t\t...(error.stack ? [[`${base}.stack`, formatStackTrace(error.stack)] as LogEntry] : []),\n\t\t\t...(error.cause instanceof Error ? errorToLogEntries(`${base}.cause`, error.cause) : []),\n\t\t];\n\t} else {\n\t\treturn [\n\t\t\t[base, `${error}`],\n\t\t];\n\t}\n}\n\n/**\n * Formats a JS stack trace in to a legible one-liner.\n */\nfunction formatStackTrace(stackTrace: string): string {\n\tconst regex = /at (.+?)$/gm;\n\tconst matches = [...stackTrace.matchAll(regex)];\n\t// Reverse array since the OpenGB stack goes from top level -> bottom level\n\tmatches.reverse();\n\treturn matches\n\t\t.map((match) => match[1]!.trim())\n\t\t.join(\" > \");\n}\n",
"packages/runtime/src/mod.ts":"export * from \"./context.ts\";\nexport * from \"./error.ts\";\nexport * from \"./runtime.ts\";\nexport * from \"./trace.ts\";\nexport * from \"./environment.ts\";\n\n// This will shim console.log\nimport \"./logger.ts\";\n",
"packages/runtime/src/postgres.ts":"import { Module } from \"./runtime.ts\";\nimport { Config } from \"./mod.ts\";\nimport { Environment } from \"./environment.ts\";\n\nconst DEFAULT_DATABASE_URL = \"postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable\";\n\nexport function getDatabaseUrl(env: Environment): URL {\n\treturn new URL(env.get(\"DATABASE_URL\") ?? DEFAULT_DATABASE_URL);\n}\n\n/**\n * Unknown driver type.\n */\nexport interface PgPoolDummy {\n\tend?: () => Promise<void>;\n}\n\n/**\n * We don't have access to the generated Prisma type, so we create an interface with only what we need to interact with.\n *\n * This will be converted to the full Prisma type when passed to the context.\n */\nexport interface PrismaClientDummy {\n\t$disconnect(): Promise<void>;\n}\n\n/** Manages Postgres connections. */\nexport class Postgres {\n\tprivate isShutDown = false;\n\n\tprivate pgPool?: PgPoolDummy;\n\tpublic prismaClients = new Map<string, PrismaClientDummy>();\n\n\tpublic async shutdown() {\n\t\tthis.isShutDown = true;\n\t\tfor (const client of this.prismaClients.values()) {\n\t\t\tawait client.$disconnect();\n\t\t}\n\t\tif (this.pgPool?.end) await this.pgPool.end();\n\t}\n\n\tpublic getOrCreatePgPool(env: Environment, config: Config): PgPoolDummy {\n\t\tif (this.isShutDown) throw new Error(\"Postgres is shutting down\");\n\n\t\tif (this.pgPool) {\n\t\t\treturn this.pgPool;\n\t\t} else {\n\t\t\tconst url = getDatabaseUrl(env);\n\n\t\t\t// Create & insert pool\n\t\t\tconst output = config.db.createPgPool(url);\n\t\t\tthis.pgPool = output;\n\t\t\treturn output;\n\t\t}\n\t}\n\n\tpublic getOrCreatePrismaClient(env: Environment, config: Config, module: Module): PrismaClientDummy | undefined {\n\t\tif (!module.db) return undefined;\n\t\tif (this.isShutDown) throw new Error(\"Postgres is shutting down\");\n\n\t\tif (this.prismaClients.has(module.db.schema)) {\n\t\t\treturn this.prismaClients.get(module.db.schema)!;\n\t\t} else {\n\t\t\t// Create & insert pool\n\t\t\tconst pool = this.getOrCreatePgPool(env, config);\n\t\t\tconst client = module.db.createPrismaClient(pool, module.db.schema);\n\t\t\tthis.prismaClients.set(module.db.schema, client);\n\t\t\treturn client;\n\t\t}\n\t}\n}\n\n/** Dummy type to represent places where we reference a specific database. */\nexport type PostgresWrapped<T> = T;\n",
"packages/runtime/src/proxy.ts":"import { Context, Runtime, Trace } from \"./mod.ts\";\nimport { RequestOf, ResponseOf } from \"./types/registry.ts\";\nimport { ActorProxy } from \"./actor/proxy.ts\";\nimport { ContextParams } from \"./context.ts\";\n\ntype ModuleRegistryPair = readonly [string, string];\n\n/**\n * This type is used denote a map the key/value pairs of one registry to\n * another.\n *\n * Example:\n * ```ts\n * type TestReg1 = {\n *   foo: {\n *     bar: { request: FooBarRequest, response: FooBarResponse },\n *     baz: { request: FooBazRequest, response: FooBazResponse },\n *   },\n *   fil: {\n *     qux: { request: FilQuxRequest, response: FilQuxResponse },\n *     cor: { request: FilCorRequest, response: FilCorResponse },\n *   }\n * };\n *\n * type TestReg2 = {\n *   canonicalFoo: {\n *     bar: { request: FooBarRequest, response: FooBarResponse },\n *     bazScript: { request: FooBazRequest, response: FooBazResponse },\n *   },\n *   filMod: {\n *     qux: { request: FilQuxRequest, response: FilQuxResponse },\n *     cor: { request: FilCorRequest, response: FilCorResponse },\n *   },\n * };\n *\n * const map: RegistryCallMap<TestReg1, TestReg2> = {\n *   foo: {\n *     bar: [\"canonicalFoo\", \"bar\"],\n *     baz: [\"canonicalFoo\", \"bazScript\"],\n *   },\n *   fil: {\n *     qux: [\"filMod\", \"qux\"],\n *     cor: [\"filMod\", \"cor\"],\n *   },\n * };\n * ```\n *\n * This is used by the {@linkcode buildDependencyRegistryProxy} function to map the camel\n * case keys from `ctx.modules.<camelMod>.<camelScript>(data);` to an\n * equivalent call to `ctx.call(<snake_mod>, <snake_script>, data);`.\n */\nexport type RegistryCallMap = Record<string, ModuleCallMap>;\n\nexport type ModuleCallMap = Record<string, ModuleRegistryPair>;\n\n/**\n * A callable registry is an object that describes the structure of\n * `ctx.modules`.\n *\n * If we have a registry like this:\n * - module `foo`\n *   - script `bar`\n *     - request type `BarRequest`\n *     - response type `BarResponse`\n *   - script `baz`\n *     - request type `BazRequest`\n *     - response type `BazResponse`\n * - module `fil`\n *   - script `qux`\n *     - request type `QuxRequest`\n *     - response type `QuxResponse`\n *   - script `cor`\n *     - request type `CorRequest`\n *     - response type `CorResponse`\n *\n * The callable registry would look like this:\n * ```ts\n * type CallableRegistry_TestReg = {\n *   foo: {\n *     bar: (req: BarRequest) => Promise<BarResponse>,\n *     baz: (req: BazRequest) => Promise<BazResponse>,\n *   },\n *   fil: {\n *     qux: (req: QuxRequest) => Promise<QuxResponse>,\n *     cor: (req: CorRequest) => Promise<CorResponse>,\n *   },\n * }\n * ```\n *\n * This is the type returned by the {@linkcode buildDependencyRegistryProxy} function.\n *\n * It is accessible to the user as `ctx.modules`.\n */\nexport type CallableDependencies<DependenciesT> = {\n\t[Mod in keyof DependenciesT]: {\n\t\t[Script in keyof DependenciesT[Mod]]: (\n\t\t\treq: RequestOf<DependenciesT[Mod][Script]>,\n\t\t) => Promise<ResponseOf<DependenciesT[Mod][Script]>>;\n\t};\n};\n\n/**\n * TODO: Comment\n */\nexport type ActorProxies<ActorsT> = {\n\t[Actor in keyof ActorsT]: ActorProxy;\n};\n\n/**\n * @param ctx The {@link Context} object to use to call the scripts in\n * accessible modules\n * @param map A {@link MapFrom} object that describes how to map\n * `[module, script] pairs from a camelCase registry to a snake_case registry\n * @returns A {@link CallableDependencies} object that implements the \"syntax sugar\"\n * that used in the `ctx.modules.<script>.<name>()` pattern to call scripts\n * without the `ctx.call` function.\n */\nexport function buildDependencyRegistryProxy<Params extends ContextParams>(\n\tctx: Context<Params>,\n\tdependenciesMapCamelToSnake: RegistryCallMap,\n): CallableDependencies<Params[\"dependenciesCamel\"]> {\n\tconst handler = {\n\t\tget: (_target: unknown, camelCaseModuleKey: string) => {\n\t\t\tif (camelCaseModuleKey in dependenciesMapCamelToSnake) {\n\t\t\t\tconst camelToSnakeMapForModule = dependenciesMapCamelToSnake[camelCaseModuleKey]!;\n\n\t\t\t\treturn new Proxy(camelToSnakeMapForModule, {\n\t\t\t\t\tget: (_target: unknown, scriptProp: string) => {\n\t\t\t\t\t\tif (scriptProp in camelToSnakeMapForModule) {\n\t\t\t\t\t\t\tconst [snakeCaseModule, snakeCaseScript] = camelToSnakeMapForModule[scriptProp]!;\n\t\t\t\t\t\t\treturn (req: unknown) => {\n\t\t\t\t\t\t\t\treturn ctx.call(\n\t\t\t\t\t\t\t\t\tsnakeCaseModule as any,\n\t\t\t\t\t\t\t\t\tsnakeCaseScript as any,\n\t\t\t\t\t\t\t\t\treq as any,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t},\n\t};\n\treturn new Proxy({}, handler) as CallableDependencies<Params[\"dependenciesCamel\"]>;\n}\n\nexport function buildActorRegistryProxy<ActorsSnakeT, ActorsCamelT>(\n\truntime: Runtime<any>,\n\tactorMap: ModuleCallMap,\n\ttrace: Trace,\n): ActorProxies<ActorsCamelT> {\n\treturn new Proxy(actorMap, {\n\t\tget: (_target: unknown, actorProp: string) => {\n\t\t\tif (actorProp in actorMap) {\n\t\t\t\tconst pair = actorMap[actorProp as keyof typeof actorMap]!;\n\t\t\t\treturn new ActorProxy(\n\t\t\t\t\truntime.actorDriver,\n\t\t\t\t\tpair[0] as any,\n\t\t\t\t\tpair[1] as any,\n\t\t\t\t\ttrace,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t},\n\t}) as ActorProxies<ActorsCamelT>;\n}\n",
"packages/runtime/src/responses.ts":"import { errorToLogEntries } from \"./logger.ts\";\nimport { Context, INTERNAL_ERROR_DESCRIPTION, RuntimeError } from \"./mod.ts\";\n\n/**\n * Builds a response indicating that the route was not found.\n *\n * Essentially a 404.\n *\n * This is used both in route calls and script calls.\n *\n * @returns A response indicating that the route was not found at the requested\n * URL.\n */\nexport function notFoundResponse<Ctx extends Context<any>>(ctx: Ctx, path: string): Response {\n\tctx.log.error(\n\t\t\"path not found\",\n\t\t[\"path\", path],\n\t);\n\treturn new Response(\n\t\tJSON.stringify({\n\t\t\tmessage: \"Route not found. Make sure the URL and method are correct.\",\n\t\t}),\n\t\t{\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t},\n\t\t\tstatus: 404,\n\t\t},\n\t);\n}\n\n/**\n * Builds a response indicating that although the route was found, the request\n * body (JSON) was invalid or did not validate.\n *\n * Used only in script calls.\n *\n * @returns A response indicating that the request body was invalid for the\n * script called.\n */\nexport function badBodyResponse<Ctx extends Context<any>>(ctx: Ctx, issue?: string): Response {\n\tif (issue) {\n\t\tctx.log.error(\n\t\t\t\"request body error\",\n\t\t\t[\"issue\", issue ?? \"bad body\"],\n\t\t);\n\t} else {\n\t\tctx.log.error(\"bad body\");\n\t}\n\n\tconst reason = issue || \"Not JSON, invalid format, or bad data\";\n\treturn new Response(\n\t\tJSON.stringify({\n\t\t\tmessage: `Request has an invalid body. (${reason})`,\n\t\t}),\n\t\t{\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t},\n\t\t\tstatus: 400,\n\t\t},\n\t);\n}\n\n/**\n * Builds a response from an unknown `e`, handling both the case where `e` is a\n * {@linkcode RuntimeError} and the case where it is not.\n *\n * @param e The (maybe {@linkcode RuntimeError}) error to be converted into a\n * response\n * @returns A response indicating that an unknown error occurred in the server\n * OR that a {@linkcode RuntimeError} occurred.\n */\nexport function serverOrRuntimeError<Ctx extends Context<any>>(ctx: Ctx, e: unknown): Response {\n\tconst status = e instanceof RuntimeError ? e.statusCode : 500;\n\tlet output: unknown;\n\tif (e instanceof RuntimeError) {\n\t\tctx.log.error(\n\t\t\t\"caught error\",\n\t\t\t...errorToLogEntries(\"error\", e),\n\t\t);\n\n\t\t// Never return error details to the client in order to prevent reverse\n\t\t// engineering & accidentally leaking secrets.\n\t\toutput = {\n\t\t\tmessage: e.internal ? INTERNAL_ERROR_DESCRIPTION : e.message,\n\t\t};\n\t} else {\n\t\tctx.log.error(\"unknown error\", [\"error\", JSON.stringify(e)]);\n\t\toutput = {\n\t\t\tmessage: INTERNAL_ERROR_DESCRIPTION\n\t\t};\n\t}\n\treturn new Response(\n\t\tJSON.stringify(output),\n\t\t{\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t},\n\t\t\tstatus,\n\t\t},\n\t);\n}\n",
"packages/runtime/src/runtime.ts":"import { ModuleContextParams, ScriptContext } from \"./context.ts\";\nimport { Context, RouteContext, TestContext } from \"./context.ts\";\nimport { PgPoolDummy, Postgres, PrismaClientDummy } from \"./postgres.ts\";\nimport { TraceEntryType } from \"./trace.ts\";\nimport { newTrace } from \"./trace.ts\";\nimport { RegistryCallMap } from \"./proxy.ts\";\nimport { ActorDriver } from \"./actor/driver.ts\";\nimport { ActorBase } from \"./actor/actor.ts\";\nimport { QualifiedPathPair } from \"../../path_resolver/src/mod.ts\";\nimport { ContextParams } from \"./mod.ts\";\nimport { errorToLogEntries, log, LOGGER_CONFIG } from \"./logger.ts\";\nimport { Environment } from \"./environment.ts\";\n\ninterface ParseSuccessResult<Output = unknown> {\n\tsuccess: true;\n\tdata: Output;\n\terror?: never;\n}\n\ninterface ParseErrorResult {\n\tsuccess: false;\n\terror: Error;\n\tdata?: never;\n}\n\ninterface ValidationSchema {\n\tsafeParseAsync: <Output = unknown>(\n\t\tdata: unknown,\n\t) => Promise<\n\t\tParseSuccessResult<Output> | ParseErrorResult\n\t>;\n}\n\nexport interface Config {\n\truntime: BuildRuntime;\n\tmodules: Record<string, Module>;\n\tcors?: CorsConfig;\n\tdb: {\n\t\tcreatePgPool: (url: URL) => PgPoolDummy;\n\t};\n}\n\n/**\n * Which runtime to target when building.\n */\nexport enum BuildRuntime {\n\tDeno,\n\tCloudflare,\n}\n\nexport interface Module {\n\tstorageAlias: string;\n\tscripts: Record<string, Script>;\n\tactors: Record<string, Actor>;\n\troutes: Record<string, Route>;\n\terrors: Record<string, ErrorConfig>;\n\tdb?: {\n\t\t/** Name of the Postgres schema the tables live in. */\n\t\tschema: string;\n\t\tcreatePrismaClient: (pool: PgPoolDummy, schema: string) => PrismaClientDummy;\n\t};\n\tdependencies: Set<string>;\n\tuserConfig: unknown;\n}\n\nexport interface CorsConfig {\n\torigins: Set<string>;\n}\n\nexport interface Script {\n\t// deno-lint-ignore no-explicit-any\n\trun: ScriptRun<any, any, any, any, any>;\n\trequestSchema: ValidationSchema;\n\tresponseSchema: ValidationSchema;\n\tpublic: boolean;\n}\n\nexport interface RouteBase {\n\t// deno-lint-ignore no-explicit-any\n\trun: RouteRun<any, any, any>;\n\tmethods: Set<string>;\n}\n\nexport interface PrefixRoute extends RouteBase {\n\tpathPrefix: string;\n}\n\nexport interface ExactRoute extends RouteBase {\n\tpath: string;\n}\n\nexport type Route = ExactRoute | PrefixRoute;\n\nexport type ScriptRun<Req, Res, UserConfigT, DatabaseT, DatabaseSchemaT> = (\n\tctx: ScriptContext<{\n\t\tdependenciesSnake: any;\n\t\tdependenciesCamel: any;\n\t\tactorsSnake: any;\n\t\tactorsCamel: any;\n\t\tuserConfig: UserConfigT;\n\t\tdatabase: DatabaseT;\n\t\tdatabaseSchema: DatabaseSchemaT;\n\t}>,\n\treq: Req,\n) => Promise<Res>;\n\nexport interface Actor {\n\t// This monstrosity is to allow passing the constructor a subclass of ActorBase.\n\tactor: new (\n\t\t...args: ConstructorParameters<typeof ActorBase<unknown, unknown>>\n\t) => ActorBase<unknown, unknown>;\n\tstorageAlias: string;\n}\n\nexport type RouteRun<UserConfigT, DatabaseT, DatabaseSchemaT> = (\n\tctx: RouteContext<{\n\t\tdependenciesSnake: any;\n\t\tdependenciesCamel: any;\n\t\tactorsSnake: any;\n\t\tactorsCamel: any;\n\t\tuserConfig: UserConfigT;\n\t\tdatabase: DatabaseT;\n\t\tdatabaseSchema: DatabaseSchemaT;\n\t}>,\n\treq: Request,\n) => Promise<Response>;\n\nexport interface ErrorConfig {\n\tdescription?: string;\n}\n\nexport class Runtime<Params extends ContextParams> {\n\tpublic postgres: Postgres;\n\n\tpublic hostname: string;\n\tpublic port: number;\n\tpublic publicEndpoint: string;\n\n\tpublic constructor(\n\t\tpublic readonly env: Environment,\n\t\tpublic readonly config: Config,\n\t\tpublic actorDriver: ActorDriver,\n\t\tprivate dependencyCaseConversionMap: RegistryCallMap,\n\t\tprivate actorCaseConversionMap: RegistryCallMap,\n\t) {\n\t\t// Read config\n\t\tthis.hostname = env.get(\"OPENGB_HOSTNAME\") ?? \"127.0.0.1\";\n\t\tthis.port = parseInt(env.get(\"OPENGB_PORT\") ?? \"6420\");\n\t\tthis.publicEndpoint = env.get(\"OPENGB_PUBLIC_ENDPOINT\") ?? `http://${this.hostname}:${this.port}`;\n\n\t\t// Configure logger\n\t\tLOGGER_CONFIG.enableSpreadObject = env.get(\"_OPENGB_LOG_SPILT_OBJECT\") == \"1\";\n\n\t\tif (env.get(\"OPENGB_TERM_COLOR\") === \"never\") {\n\t\t\tLOGGER_CONFIG.enableColor = false;\n\t\t} else if (env.get(\"OPENGB_TERM_COLOR\") === \"always\") {\n\t\t\tLOGGER_CONFIG.enableColor = true;\n\t\t} else if (env.get(\"NO_COLOR\") != undefined && env.get(\"NO_COLOR\") != \"\") {\n\t\t\t// https://no-color.org/\n\t\t\tLOGGER_CONFIG.enableColor = false;\n\t\t} else {\n\t\t\tLOGGER_CONFIG.enableColor = globalThis.Deno?.stdout?.isTerminal() == true;\n\t\t}\n\n\t\t// Create database\n\t\tthis.postgres = new Postgres();\n\t}\n\n\tprivate async shutdown() {\n\t\tawait this.postgres.shutdown();\n\t}\n\n\tpublic createRootContext(\n\t\ttraceEntryType: TraceEntryType,\n\t): Context<{\n\t\tdependenciesSnake: Params[\"dependenciesSnake\"];\n\t\tdependenciesCamel: Params[\"dependenciesCamel\"];\n\t\tactorsSnake: Params[\"actorsSnake\"];\n\t\tactorsCamel: Params[\"actorsCamel\"];\n\t}> {\n\t\treturn new Context(\n\t\t\tthis,\n\t\t\tnewTrace(traceEntryType, this.config.runtime),\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t\tthis.actorCaseConversionMap,\n\t\t);\n\t}\n\n\tpublic createRouteContext(\n\t\tctx: Context<Params>,\n\t\tmoduleName: string,\n\t\trouteName: string,\n\t) {\n\t\t// FIXME: This is a pretty terrible hack. We should find a better way to\n\t\t// do this, probably with a \"public\" underscore function.\n\t\tconst ctxWithPublicGRC = ctx as unknown as { getRouteContext: Context<Params>[\"getRouteContext\"] };\n\t\treturn ctxWithPublicGRC.getRouteContext(moduleName, routeName);\n\t}\n\n\tpublic createRootRouteContext(\n\t\ttraceEntryType: TraceEntryType,\n\t\tmoduleName: string,\n\t\trouteName: string,\n\t): RouteContext<{\n\t\t\"dependenciesSnake\": Params[\"dependenciesSnake\"];\n\t\t\"dependenciesCamel\": Params[\"dependenciesCamel\"];\n\t\t\"actorsSnake\": Params[\"actorsSnake\"];\n\t\t\"actorsCamel\": Params[\"actorsCamel\"];\n\t\t\"userConfig\": any;\n\t\t\"database\": PrismaClientDummy | undefined;\n\t\t\"databaseSchema\": any;\n\t}> {\n\t\tconst module = this.config.modules[moduleName];\n\t\tif (!module) throw new Error(`Module not found: ${moduleName}`);\n\n\t\treturn new RouteContext(\n\t\t\tthis,\n\t\t\tnewTrace(traceEntryType),\n\t\t\tmoduleName,\n\t\t\tthis.postgres.getOrCreatePrismaClient(this.env, this.config, module),\n\t\t\tmodule.db?.schema,\n\t\t\trouteName,\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t\tthis.actorCaseConversionMap,\n\t\t);\n\t}\n\n\t/**\n\t * Registers a module test with the Deno runtime.\n\t */\n\tpublic static test<Params extends ModuleContextParams>(\n\t\tconfig: Config,\n\t\tactorDriver: ActorDriver,\n\t\tmoduleName: string,\n\t\ttestName: string,\n\t\tfn: (\n\t\t\tctx: TestContext<Params>,\n\t\t) => Promise<void>,\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t\tactorDependencyCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tDeno.test({\n\t\t\tname: testName,\n\n\t\t\t// TODO: https://github.com/rivet-gg/opengb-engine/issues/35\n\t\t\tsanitizeOps: false,\n\t\t\tsanitizeResources: false,\n\n\t\t\tasync fn() {\n\t\t\t\tconst runtime = new Runtime<Params>(\n\t\t\t\t\tDeno.env,\n\t\t\t\t\tconfig,\n\t\t\t\t\tactorDriver,\n\t\t\t\t\tdependencyCaseConversionMap,\n\t\t\t\t\tactorDependencyCaseConversionMap,\n\t\t\t\t);\n\n\t\t\t\t// Build context\n\t\t\t\tconst module = config.modules[moduleName]!;\n\t\t\t\tconst ctx = new TestContext<Params>(\n\t\t\t\t\truntime,\n\t\t\t\t\tnewTrace({\n\t\t\t\t\t\ttest: { module: moduleName, name: testName },\n\t\t\t\t\t}),\n\t\t\t\t\tmoduleName,\n\t\t\t\t\truntime.postgres.getOrCreatePrismaClient(runtime.env, runtime.config, module),\n\t\t\t\t\tmodule.db?.schema,\n\t\t\t\t\tdependencyCaseConversionMap,\n\t\t\t\t\tactorDependencyCaseConversionMap,\n\t\t\t\t);\n\n\t\t\t\t// Run test\n\t\t\t\ttry {\n\t\t\t\t\tawait ctx.runBlock(async () => {\n\t\t\t\t\t\tawait fn(ctx);\n\t\t\t\t\t});\n\t\t\t\t} catch (cause) {\n\t\t\t\t\tlog(\n\t\t\t\t\t\t\"error\",\n\t\t\t\t\t\t\"failed to execute test\",\n\t\t\t\t\t\t[\"module\", moduleName],\n\t\t\t\t\t\t[\"test\", testName],\n\t\t\t\t\t\t...errorToLogEntries(\"cause\", cause),\n\t\t\t\t\t);\n\t\t\t\t\tthrow cause;\n\t\t\t\t} finally {\n\t\t\t\t\tawait runtime.shutdown();\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Only runs on a CORS preflight request returns a response with the\n\t * appropriate CORS headers & status.\n\t *\n\t * @param req The preflight OPTIONS request\n\t * @returns The full response to the preflight request\n\t */\n\tpublic corsPreflight(req: Request): Response {\n\t\tconst origin = req.headers.get(\"Origin\");\n\t\tif (origin) {\n\t\t\tconst normalizedOrigin = new URL(origin).origin;\n\t\t\tif (this.config.cors) {\n\t\t\t\tif (this.config.cors.origins.has(normalizedOrigin)) {\n\t\t\t\t\treturn new Response(undefined, {\n\t\t\t\t\t\tstatus: 204,\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t...this.corsHeaders(req),\n\t\t\t\t\t\t\t\"Vary\": \"Origin\",\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Origin is not allowed/no origin header on preflight\n\t\treturn new Response(\n\t\t\tJSON.stringify({\n\t\t\t\t\"message\": \"CORS origin not allowed. See https://opengb.dev/docs/cors\",\n\t\t\t}),\n\t\t\t{\n\t\t\t\tstatus: 403,\n\t\t\t\theaders: {\n\t\t\t\t\t\"Vary\": \"Origin\",\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\t}\n\n\tpublic corsHeaders(req: Request): Record<string, string> {\n\t\tconst origin = req.headers.get(\"Origin\");\n\n\t\t// Don't set CORS headers if there's no origin (e.g. a server-side\n\t\t// request)\n\t\tif (!origin) return {};\n\n\t\t// If the origin is allowed, return the appropriate headers.\n\t\t// Otherwise, return a non-matching cors header (empty object).\n\t\tif (this.config.cors?.origins.has(origin)) {\n\t\t\treturn {\n\t\t\t\t\"Access-Control-Allow-Origin\": new URL(origin).origin,\n\t\t\t\t\"Access-Control-Allow-Methods\": \"*\",\n\t\t\t\t\"Access-Control-Allow-Headers\": \"*\",\n\t\t\t};\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n\n\tpublic corsAllowed(req: Request): boolean {\n\t\tconst origin = req.headers.get(\"Origin\");\n\n\t\tif (!origin) return true;\n\t\treturn this.config.cors?.origins.has(origin) ?? false;\n\t}\n\n\tpublic routePaths(): QualifiedPathPair[] {\n\t\tconst paths: QualifiedPathPair[] = [];\n\t\tfor (const [moduleName, module] of Object.entries(this.config.modules)) {\n\t\t\tfor (const [routeName, route] of Object.entries(module.routes)) {\n\t\t\t\tif (\"path\" in route) {\n\t\t\t\t\tpaths.push({\n\t\t\t\t\t\tmodule: moduleName,\n\t\t\t\t\t\troute: routeName,\n\t\t\t\t\t\tpath: { path: route.path, isPrefix: false },\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tpaths.push({\n\t\t\t\t\t\tmodule: moduleName,\n\t\t\t\t\t\troute: routeName,\n\t\t\t\t\t\tpath: { path: route.pathPrefix, isPrefix: true },\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n}\n\nexport type PathPair = { path: string; isPrefix: boolean };\n",
"packages/runtime/src/server.ts":"import { LogEntry } from \"./logger.ts\";\nimport { Context, ContextParams, ModuleContextParams, Route, Script } from \"./mod.ts\";\nimport { Runtime } from \"./runtime.ts\";\nimport { PathResolver } from \"../../path_resolver/src/mod.ts\";\nimport { badBodyResponse, notFoundResponse, serverOrRuntimeError } from \"./responses.ts\";\n\nconst MODULE_CALL = /^\\/modules\\/(?<module>\\w+)\\/scripts\\/(?<script>\\w+)\\/call\\/?$/;\n\ninterface RequestInfo {\n\tremoteAddress: string;\n}\n\nexport async function handleRequest<Params extends ModuleContextParams>(\n\truntime: Runtime<Params>,\n\treq: Request,\n\tinfo: RequestInfo,\n\tresolver: PathResolver,\n): Promise<Response> {\n\tconst url = new URL(req.url);\n\n\t// Create context\n\tconst ctx = runtime.createRootContext({\n\t\thttpRequest: {\n\t\t\tmethod: req.method,\n\t\t\tpath: url.pathname,\n\t\t\tremoteAddress: info.remoteAddress,\n\t\t\theaders: Object.fromEntries(req.headers.entries()),\n\t\t},\n\t});\n\n\t// Log request\n\tconst start = performance.now();\n\tctx.log.debug(\n\t\t\"http request\",\n\t\t[\"method\", req.method],\n\t\t[\"path\", url.pathname],\n\t\t[\"remoteAddress\", info.remoteAddress],\n\t\t[\"userAgent\", req.headers.get(\"user-agent\")],\n\t);\n\n\t// Execute request\n\tconst res = await handleRequestInner(runtime, req, url, ctx, resolver);\n\n\t// Log response\n\t//\n\t// `duration` will be 0 on Cloudflare Workers if there are no async actions\n\t// performed inside of the request:\n\t// https://developers.cloudflare.com/workers/runtime-apis/performance/\n\tconst duration = Math.ceil(performance.now() - start);\n\tctx.log.debug(\n\t\t\"http response\",\n\t\t[\"status\", res.status],\n\t\t...(duration > 0 ? [[\"duration\", `${duration}ms`] as LogEntry] : []),\n\t);\n\n\treturn res;\n}\n\nasync function handleRequestInner<Params extends ModuleContextParams>(\n\truntime: Runtime<Params>,\n\treq: Request,\n\turl: URL,\n\tctx: Context<Params>,\n\tresolver: PathResolver,\n): Promise<Response> {\n\t// MARK: Handle CORS\n\n\t// Handle CORS preflight\n\tif (req.method === \"OPTIONS\") {\n\t\treturn runtime.corsPreflight(req);\n\t}\n\n\t// Disallow even simple requests if CORS is not allowed\n\tif (!runtime.corsAllowed(req)) {\n\t\treturn new Response(undefined, {\n\t\t\tstatus: 403,\n\t\t\theaders: {\n\t\t\t\t\"Vary\": \"Origin\",\n\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t},\n\t\t});\n\t}\n\n\t// MARK: Handle Scripts\n\tconst matches = MODULE_CALL.exec(url.pathname);\n\tif (matches?.groups) {\n\t\t// Only allow POST requests\n\t\tif (req.method !== \"POST\") {\n\t\t\treturn new Response(undefined, {\n\t\t\t\tstatus: 405,\n\t\t\t\theaders: {\n\t\t\t\t\t\"Allow\": \"POST\",\n\t\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\t// Lookup script\n\t\tconst moduleName = matches.groups.module!;\n\t\tconst scriptName = matches.groups.script!;\n\t\tconst script = runtime.config.modules[moduleName]?.scripts[scriptName];\n\t\tif (!script) return notFoundResponse(ctx, url.pathname);\n\n\t\treturn handleScriptCall(req, url, ctx, moduleName, scriptName, script);\n\t}\n\n\t// MARK: Handle Routes\n\t// Route call\n\tconst resolved = resolver.resolve(url.pathname);\n\tif (!resolved) return notFoundResponse(ctx, url.pathname);\n\n\tconst { module, route } = resolved;\n\n\tconst routeObj = runtime.config.modules[module]?.routes?.[route];\n\tif (!routeObj) return notFoundResponse(ctx, url.pathname);\n\n\treturn handleRouteCall(runtime, req, url, ctx, module, route, routeObj);\n}\n\nexport async function handleScriptCall<Params extends ContextParams>(\n\treq: Request,\n\turl: URL,\n\tctx: Context<Params>,\n\tmoduleName: string,\n\tscriptName: string,\n\tscript: Script,\n) {\n\t// If a script is not public, return 404\n\tif (!script.public) return notFoundResponse(ctx, url.pathname);\n\n\t// Parse body\n\tlet body: any;\n\ttry {\n\t\tbody = await req.json();\n\t} catch {\n\t\treturn badBodyResponse(ctx, \"invalid JSON\");\n\t}\n\n\tlet output: any;\n\ttry {\n\t\t// Call module\n\t\toutput = await ctx.call(\n\t\t\tmoduleName as any,\n\t\t\tscriptName as any,\n\t\t\tbody,\n\t\t);\n\t} catch (error) {\n\t\treturn serverOrRuntimeError(ctx, error);\n\t}\n\n\treturn new Response(\n\t\tJSON.stringify(output),\n\t\t{\n\t\t\tstatus: 200,\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t},\n\t\t},\n\t);\n}\n\nexport async function handleRouteCall<Params extends ContextParams>(\n\truntime: Runtime<Params>,\n\treq: Request,\n\turl: URL,\n\tctx: Context<Params>,\n\tmoduleName: string,\n\trouteName: string,\n\troute: Route,\n) {\n\tif (!route.methods.has(req.method)) notFoundResponse(ctx, url.pathname);\n\n\tconst routeCtx = runtime.createRouteContext(ctx, moduleName, routeName);\n\n\t// Call route\n\tconst res = await ctx.runBlock(async () => await route.run(routeCtx, req));\n\tconsole.log(\n\t\t`Route Response ${moduleName}.${routeName}:\\n${JSON.stringify(res, null, 2)}`,\n\t);\n\n\treturn res;\n}\n",
"packages/runtime/src/trace.ts":"import { JsonObject } from \"./types/json.ts\";\nimport { UnreachableError } from \"./error.ts\";\nimport { log } from \"./logger.ts\";\nimport { BuildRuntime } from \"./runtime.ts\";\n\n/**\n * Provides context about where this script call came from.\n */\nexport interface Trace extends JsonObject {\n\trayId: string;\n\tentries: TraceEntry[];\n}\n\n/**\n * Single entry in the trace.\n */\nexport interface TraceEntry extends JsonObject {\n\trequestId: string;\n\tstartedAt: string;\n\ttype: TraceEntryType;\n}\n\n/**\n * Infomration about the type of the trace entry.\n */\nexport type TraceEntryType =\n\t| { httpRequest: TraceEntryTypeHttpRequest }\n\t| {\n\t\tscript: TraceEntryTypeScript;\n\t}\n\t| {\n\t\troute: TraceEntryTypeRoute;\n\t}\n\t| { actorInitialize: TraceEntryTypeActorInitialize }\n\t| { actorGetOrCreateAndCall: TraceEntryTypeActorCall }\n\t| { actorCall: TraceEntryTypeActorCall }\n\t| { actorSchedule: TraceEntryTypeActorSchedule }\n\t| { test: TraceEntryTypeTest }\n\t| { internalTest: TraceEntryTypeInternalTest };\n\nexport function stringifyTrace(trace: Trace) {\n\treturn trace.entries.map((x) => stringifyTraceEntryType(x.type)).join(\" > \");\n}\n\nexport function stringifyTraceEntryType(trace: TraceEntryType) {\n\tif (\"httpRequest\" in trace) {\n\t\treturn \"httpRequest\";\n\t} else if (\"script\" in trace) {\n\t\tconst { module, script } = trace.script;\n\t\treturn `script(${module}.${script})`;\n\t} else if (\"route\" in trace) {\n\t\tconst { module, route } = trace.route;\n\t\treturn `route(${module}.${route})`;\n\t} else if (\"actorInitialize\" in trace) {\n\t\tconst { module, actor } = trace.actorInitialize;\n\t\treturn `actorInitialize(${module}.${actor})`;\n\t} else if (\"actorGetOrCreateAndCall\" in trace) {\n\t\tconst { module, actor, fn } = trace.actorGetOrCreateAndCall;\n\t\treturn `actorGetOrCreateAndCall(${module}.${actor}.${fn})`;\n\t} else if (\"actorCall\" in trace) {\n\t\tconst { module, actor, fn } = trace.actorCall;\n\t\treturn `actorCall(${module}.${actor}.${fn})`;\n\t} else if (\"actorSchedule\" in trace) {\n\t\treturn \"actorSchedule\";\n\t} else if (\"test\" in trace) {\n\t\tconst { module, name } = trace.test;\n\t\treturn `test(${module}.${name})`;\n\t} else if (\"internalTest\" in trace) {\n\t\treturn \"internalTest\";\n\t} else {\n\t\tthrow new UnreachableError(trace);\n\t}\n}\n\nexport interface TraceEntryTypeHttpRequest extends JsonObject {\n\tmethod: string;\n\tpath: string;\n\tremoteAddress: string;\n\theaders: { [key: string]: string };\n}\n\nexport interface TraceEntryTypeScript extends JsonObject {\n\tmodule: string;\n\tscript: string;\n}\n\nexport interface TraceEntryTypeRoute extends JsonObject {\n\tmodule: string;\n\troute: string;\n}\n\nexport interface TraceEntryTypeActorInitialize extends JsonObject {\n\tmodule: string;\n\tactor: string;\n}\n\nexport interface TraceEntryTypeActorCall extends JsonObject {\n\tmodule: string;\n\tactor: string;\n\tfn: string;\n}\n\nexport interface TraceEntryTypeActorSchedule extends JsonObject {}\n\nexport interface TraceEntryTypeTest extends JsonObject {\n\tmodule: string;\n\tname: string;\n}\n\nexport interface TraceEntryTypeInternalTest extends JsonObject {\n}\n\nexport function newTrace(entryType: TraceEntryType, runtime: BuildRuntime = BuildRuntime.Deno): Trace {\n\tconst entry: TraceEntry = {\n\t\trequestId: crypto.randomUUID(),\n\t\tstartedAt: new Date().toISOString(),\n\t\ttype: entryType,\n\t};\n\n\t// Read managed opengb ray id from request header (set by cloudflare)\n\tlet rayId: string;\n\tif (runtime == BuildRuntime.Cloudflare && \"httpRequest\" in entry) {\n\t\tconst rayIdHeader = (entry.httpRequest as TraceEntryTypeHttpRequest).headers[\"x-opengb-ray-id\"];\n\t\tif (rayIdHeader) {\n\t\t\trayId = rayIdHeader;\n\t\t} else {\n\t\t\tlog(\"warn\", \"no x-opengb-ray-id header found\");\n\t\t\t// Generate random ray ID\n\t\t\trayId = crypto.randomUUID();\n\t\t}\n\t} else {\n\t\t// Generate random ray ID\n\t\trayId = crypto.randomUUID();\n\t}\n\n\treturn {\n\t\trayId,\n\t\tentries: [entry],\n\t};\n}\n\n/**\n * Returns a new trace with the given entry appended to it.\n */\nexport function appendTraceEntry(\n\ttrace: Trace,\n\tentryType: TraceEntryType,\n): Trace {\n\tconst entry: TraceEntry = {\n\t\trequestId: crypto.randomUUID(),\n\t\tstartedAt: new Date().toISOString(),\n\t\ttype: entryType,\n\t};\n\n\treturn {\n\t\trayId: trace.rayId,\n\t\tentries: [...trace.entries, entry],\n\t};\n}\n",
"packages/runtime/src/types/json.ts":"/**\n * A JSON type that can be clealy serialized to/from JSON.\n */\nexport declare type JsonValue =\n\t| string\n\t| number\n\t| boolean\n\t| JsonObject\n\t| JsonArray\n\t| null;\n\n/**\n * A JSON array that can be clealy serialized to/from JSON.\n */\nexport declare interface JsonArray extends Array<JsonValue> {\n}\n\n/**\n * A JSON object that can be clealy serialized to/from JSON.\n */\nexport declare type JsonObject = {\n\t[Key in string]?: JsonValue;\n};\n",
"packages/runtime/src/types/registry.ts":"export type BaseRegistryBounds = Record<any, Record<any, { request: any; response: any }>>;\n\nexport type RequestOf<T> = T extends { request: any } ? T[\"request\"] : never;\nexport type ResponseOf<T> = T extends { response: any } ? T[\"response\"] : never;\n\nexport type DependencyScriptCallFunction<ThisType, Dependencies> = <\n\tM extends keyof Dependencies & string,\n\tS extends keyof Dependencies[M] & string,\n>(\n\tthis: ThisType,\n\tmodule: M,\n\tscript: S,\n\treq: RequestOf<Dependencies[M][S]>,\n) => Promise<ResponseOf<Dependencies[M][S]>>;\n"
}