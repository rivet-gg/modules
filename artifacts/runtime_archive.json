{"src/deps.ts":"export {\n\tdirname,\n\tformat as formatPath,\n\tfromFileUrl,\n\tisAbsolute,\n\tparse as parsePath,\n\trelative,\n\tresolve,\n\tSEP,\n} from \"https://deno.land/std@0.208.0/path/mod.ts\";\nexport { copy, emptyDir, exists, move } from \"https://deno.land/std@0.208.0/fs/mod.ts\";\nexport { assert, assertEquals, assertExists } from \"https://deno.land/std@0.208.0/assert/mod.ts\";\n\nexport * as tjs from \"npm:typescript-json-schema@0.62.0\";\n\nimport Ajv from \"https://esm.sh/ajv@^8.12.0\";\nexport { Ajv };\n\nimport addFormats from \"https://esm.sh/ajv-formats@^2.1.1\";\nexport { addFormats };\n\n// Must match version in `esbuild_deno_loader`\n//\n// See also Prisma esbuild in `src/migrate/deps.ts`\nexport * as esbuild from \"https://deno.land/x/esbuild@v0.20.2/mod.js\";\nexport { denoPlugins } from \"jsr:@luca/esbuild-deno-loader@^0.10.3\";\n","src/utils/db.ts":"const DEFAULT_DATABASE_URL = \"postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable\";\n\nexport function getDatabaseUrl(dbName: string): URL {\n\tconst url = getDefaultDatabaseUrl();\n\turl.searchParams.set(\"schema\", dbName);\n\n\treturn url;\n}\n\nexport function getDefaultDatabaseUrl(): URL {\n\treturn new URL(Deno.env.get(\"DATABASE_URL\") ?? DEFAULT_DATABASE_URL);\n}\n","src/types/registry.ts":"export type BaseRegistryBounds = Record<any, Record<any, { request: any; response: any }>>;\n\nexport type RequestOf<T> = T extends { request: any } ? T[\"request\"] : never;\nexport type ResponseOf<T> = T extends { response: any } ? T[\"response\"] : never;\n\nexport type DependencyScriptCallFunction<ThisType, Dependencies> = <\n\tM extends keyof Dependencies & string,\n\tS extends keyof Dependencies[M] & string,\n>(\n\tthis: ThisType,\n\tmodule: M,\n\tscript: S,\n\treq: RequestOf<Dependencies[M][S]>,\n) => Promise<ResponseOf<Dependencies[M][S]>>;\n","src/types/case_conversions.ts":"export function camelify(snake: string) {\n\treturn snake.replace(/_([a-z])/g, (g) => g[1].toUpperCase());\n}\n\nexport function pascalify(snake: string) {\n\tconst camel = camelify(snake);\n\treturn camel[0].toUpperCase() + camel.slice(1);\n}\n\nexport function snakeify(camel: string) {\n\treturn camel.replace(/[A-Z]/g, (g) => `_${g.toLowerCase()}`);\n}\n","src/types/json.ts":"/**\n * A JSON type that can be clealy serialized to/from JSON.\n */\nexport declare type JsonValue =\n\t| string\n\t| number\n\t| boolean\n\t| JsonObject\n\t| JsonArray\n\t| null;\n\n/**\n * A JSON array that can be clealy serialized to/from JSON.\n */\nexport declare interface JsonArray extends Array<JsonValue> {\n}\n\n/**\n * A JSON object that can be clealy serialized to/from JSON.\n */\nexport declare type JsonObject = {\n\t[Key in string]?: JsonValue;\n};\n","src/types/expandable.ts":"export type Expandable<T> = string | T;\n","src/runtime/trace.ts":"import { JsonObject } from \"../types/json.ts\";\nimport { BuildRuntime } from \"./runtime.ts\";\n\n/**\n * Provides context about where this script call came from.\n */\nexport interface Trace extends JsonObject {\n\trayId: string;\n\tentries: TraceEntry[];\n}\n\n/**\n * Single entry in the trace.\n */\nexport interface TraceEntry extends JsonObject {\n\trequestId: string;\n\tstartedAt: string;\n\ttype: TraceEntryType;\n}\n\n/**\n * Infomration about the type of the trace entry.\n */\nexport type TraceEntryType =\n\t| { httpRequest: TraceEntryTypeHttpRequest }\n\t| {\n\t\tscript: TraceEntryTypeScript;\n\t}\n\t| { test: TraceEntryTypeTest }\n\t| { internalTest: TraceEntryTypeInternalTest };\n\nexport interface TraceEntryTypeHttpRequest extends JsonObject {\n\tmethod: string;\n\tpath: string;\n\tremoteAddress: string;\n\theaders: { [key: string]: string };\n}\n\nexport interface TraceEntryTypeScript extends JsonObject {\n\tmodule: string;\n\tscript: string;\n}\n\nexport interface TraceEntryTypeTest extends JsonObject {\n\tmodule: string;\n\tname: string;\n}\n\nexport interface TraceEntryTypeInternalTest extends JsonObject {\n}\n\nexport function newTrace(entryType: TraceEntryType, runtime: BuildRuntime = BuildRuntime.Deno): Trace {\n\tconst entry: TraceEntry = {\n\t\trequestId: crypto.randomUUID(),\n\t\tstartedAt: new Date().toISOString(),\n\t\ttype: entryType,\n\t};\n\n\t// Read managed opengb ray id from request header (set by cloudflare)\n\tlet rayId: string;\n\tif (runtime == BuildRuntime.Cloudflare && \"httpRequest\" in entry) {\n\t\trayId = (entry.httpRequest as TraceEntryTypeHttpRequest).headers[\"x-opengb-ray-id\"];\n\t} else {\n\t\t// Generate random ray ID\n\t\trayId = crypto.randomUUID();\n\t}\n\n\treturn {\n\t\trayId,\n\t\tentries: [entry],\n\t};\n}\n\n/**\n * Returns a new trace with the given entry appended to it.\n */\nexport function appendTraceEntry(\n\ttrace: Trace,\n\tentryType: TraceEntryType,\n): Trace {\n\tconst entry: TraceEntry = {\n\t\trequestId: crypto.randomUUID(),\n\t\tstartedAt: new Date().toISOString(),\n\t\ttype: entryType,\n\t};\n\n\treturn {\n\t\trayId: trace.rayId,\n\t\tentries: [...trace.entries, entry],\n\t};\n}\n","src/runtime/server.ts":"import { Runtime } from \"./runtime.ts\";\n\nconst MODULE_CALL = /^\\/modules\\/(?<module>\\w+)\\/scripts\\/(?<script>\\w+)\\/call\\/?$/;\n\ninterface RequestInfo {\n\tremoteAddress: string;\n}\n\nexport async function handleRequest<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT>(\n\truntime: Runtime<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT>,\n\treq: Request,\n\tinfo: RequestInfo,\n): Promise<Response> {\n\tconst url = new URL(req.url);\n\n\t// Handle CORS preflight\n\tif (req.method === \"OPTIONS\") {\n\t\treturn runtime.corsPreflight(req);\n\t}\n\n\t// Disallow even simple requests if CORS is not allowed\n\tif (!runtime.corsAllowed(req)) {\n\t\treturn new Response(undefined, {\n\t\t\tstatus: 403,\n\t\t\theaders: {\n\t\t\t\t\"Vary\": \"Origin\",\n\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t},\n\t\t});\n\t}\n\n\t// Only allow POST requests\n\tif (req.method !== \"POST\") {\n\t\treturn new Response(undefined, {\n\t\t\tstatus: 405,\n\t\t\theaders: {\n\t\t\t\t\"Allow\": \"POST\",\n\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t},\n\t\t});\n\t}\n\n\t// Get module and script name\n\tconst matches = MODULE_CALL.exec(url.pathname);\n\tif (!matches?.groups) {\n\t\treturn new Response(\n\t\t\tJSON.stringify({\n\t\t\t\t\"message\": \"Route not found. Make sure the URL and method are correct.\",\n\t\t\t}),\n\t\t\t{\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t\t},\n\t\t\t\tstatus: 404,\n\t\t\t},\n\t\t);\n\t}\n\n\t// Lookup script\n\tconst moduleName = matches.groups.module;\n\tconst scriptName = matches.groups.script;\n\tconst script = runtime.config.modules[moduleName]?.scripts[scriptName];\n\n\t// Confirm script exists and is public\n\tif (!script || !script.public) {\n\t\treturn new Response(\n\t\t\tJSON.stringify({\n\t\t\t\t\"message\": \"Route not found. Make sure the URL and method are correct.\",\n\t\t\t}),\n\t\t\t{\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t\t},\n\t\t\t\tstatus: 404,\n\t\t\t},\n\t\t);\n\t}\n\n\t// Create context\n\tconst ctx = runtime.createRootContext({\n\t\thttpRequest: {\n\t\t\tmethod: req.method,\n\t\t\tpath: url.pathname,\n\t\t\tremoteAddress: info.remoteAddress,\n\t\t\theaders: Object.fromEntries(req.headers.entries()),\n\t\t},\n\t});\n\n\t// Parse body\n\tlet body;\n\ttry {\n\t\tbody = await req.json();\n\t} catch {\n\t\tconst output = {\n\t\t\tmessage: \"Request must have a valid JSON body.\",\n\t\t};\n\t\treturn new Response(JSON.stringify(output), {\n\t\t\tstatus: 400,\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t},\n\t\t});\n\t}\n\n\ttry {\n\t\t// Call module\n\t\tconst output = await ctx.call(\n\t\t\tmoduleName as any,\n\t\t\tscriptName as any,\n\t\t\tbody,\n\t\t);\n\n\t\tif (output.__tempPleaseSeeOGBE3_NoData) {\n\t\t\treturn new Response(undefined, {\n\t\t\t\tstatus: 204,\n\t\t\t\theaders: {\n\t\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\treturn new Response(JSON.stringify(output), {\n\t\t\tstatus: 200,\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t},\n\t\t});\n\t} catch (e) {\n\t\t// Error response\n\t\tconst output = {\n\t\t\tmessage: e.message,\n\t\t};\n\n\t\treturn new Response(JSON.stringify(output), {\n\t\t\tstatus: 500,\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t},\n\t\t});\n\t}\n}\n","src/runtime/deps.ts":"export { QueryClient, Transaction } from \"https://deno.land/x/postgres@v0.17.2/mod.ts\";\n\nimport * as Ajv from \"https://esm.sh/ajv@^8.12.0\";\nexport { Ajv };\n\nimport addFormats from \"https://esm.sh/ajv-formats@^2.1.1\";\nexport { addFormats };\n","src/runtime/error.ts":"import { ModuleContext } from \"./context.ts\";\nimport { Context } from \"./context.ts\";\nimport { ErrorConfig, Runtime } from \"./runtime.ts\";\nimport { Trace } from \"./trace.ts\";\n\nexport interface RuntimeErrorOptions extends ErrorOptions {\n\tmeta?: any;\n}\n\nexport class RuntimeError extends Error {\n\t/**\n\t * The module this error originated from.\n\t *\n\t * Will be undefined if the error is not enriched yet.\n\t */\n\tpublic moduleName?: string;\n\n\t/**\n\t * Call trace of the error.\n\t *\n\t * Will be undefined if the error is not enriched yet.\n\t */\n\tpublic trace?: Trace;\n\n\t/**\n\t * Config of the error.\n\t *\n\t * Will be undefined if the error is not enriched yet.\n\t */\n\tpublic errorConfig?: ErrorConfig;\n\n\t/**\n\t * Additional metadata of the error.\n\t */\n\tpublic meta?: ErrorConfig;\n\n\tpublic constructor(\n\t\tpublic readonly code: string,\n\t\toptions?: RuntimeErrorOptions,\n\t) {\n\t\tsuper(code, options);\n\t\tthis.meta = options?.meta;\n\t}\n\n\t/**\n\t * Called by `Context` when an error is caught.\n\t */\n\tpublic enrich<\n\t\tDependenciesSnakeT,\n\t\tDependenciesCamelT,\n\t\tActorsSnakeT,\n\t\tActorsCamelT,\n\t\tCtx extends Context<\n\t\t\tDependenciesSnakeT,\n\t\t\tDependenciesCamelT,\n\t\t\tActorsSnakeT,\n\t\t\tActorsCamelT\n\t\t>,\n\t>(\n\t\truntime: Runtime<\n\t\t\tDependenciesSnakeT,\n\t\t\tDependenciesCamelT,\n\t\t\tActorsSnakeT,\n\t\t\tActorsCamelT\n\t\t>,\n\t\tcontext: Ctx,\n\t) {\n\t\t// Add context to error\n\t\tif (context instanceof ModuleContext) {\n\t\t\tthis.moduleName = context.moduleName;\n\t\t}\n\t\tthis.trace = context.trace;\n\n\t\t// Lookup error config\n\t\tif (this.moduleName) {\n\t\t\tconst errorConfig = runtime.config.modules[this.moduleName]\n\t\t\t\t?.errors[this.code];\n\t\t\tif (errorConfig) {\n\t\t\t\tthis.errorConfig = errorConfig;\n\t\t\t\tif (errorConfig.description) {\n\t\t\t\t\tthis.message = `${this.moduleName}[${this.code}]: ${errorConfig.description}\\nTrace: ${\n\t\t\t\t\t\tJSON.stringify(context.trace)\n\t\t\t\t\t}`;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(`Error config not found for ${this.code}`);\n\t\t\t}\n\t\t}\n\n\t\t// Build enriched message\n\t\tlet message = \"\";\n\t\tif (this.moduleName) {\n\t\t\tmessage += `${this.moduleName}[${this.code}]`;\n\t\t} else {\n\t\t\tmessage += this.code;\n\t\t}\n\t\tif (this.errorConfig?.description) {\n\t\t\tmessage += `: ${this.errorConfig.description}`;\n\t\t}\n\t\tmessage += `\\nTrace: ${JSON.stringify(this.trace)}`;\n\t\tthis.message = message;\n\t}\n}\n","src/runtime/proxy.ts":"import { Context, Runtime } from \"../runtime/mod.ts\";\nimport { RequestOf, ResponseOf } from \"../types/registry.ts\";\nimport { ActorProxy } from \"./actor.ts\";\n\ntype ModuleRegistryPair = readonly [string, string];\n\n/**\n * This type is used denote a map the key/value pairs of one registry to\n * another.\n *\n * Example:\n * ```ts\n * type TestReg1 = {\n *   foo: {\n *     bar: { request: FooBarRequest, response: FooBarResponse },\n *     baz: { request: FooBazRequest, response: FooBazResponse },\n *   },\n *   fil: {\n *     qux: { request: FilQuxRequest, response: FilQuxResponse },\n *     cor: { request: FilCorRequest, response: FilCorResponse },\n *   }\n * };\n *\n * type TestReg2 = {\n *   canonicalFoo: {\n *     bar: { request: FooBarRequest, response: FooBarResponse },\n *     bazScript: { request: FooBazRequest, response: FooBazResponse },\n *   },\n *   filMod: {\n *     qux: { request: FilQuxRequest, response: FilQuxResponse },\n *     cor: { request: FilCorRequest, response: FilCorResponse },\n *   },\n * };\n *\n * const map: RegistryCallMap<TestReg1, TestReg2> = {\n *   foo: {\n *     bar: [\"canonicalFoo\", \"bar\"],\n *     baz: [\"canonicalFoo\", \"bazScript\"],\n *   },\n *   fil: {\n *     qux: [\"filMod\", \"qux\"],\n *     cor: [\"filMod\", \"cor\"],\n *   },\n * };\n * ```\n *\n * This is used by the {@linkcode buildDependencyRegistryProxy} function to map the camel\n * case keys from `ctx.modules.<camelMod>.<camelScript>(data);` to an\n * equivalent call to `ctx.call(<snake_mod>, <snake_script>, data);`.\n */\nexport type RegistryCallMap = Record<string, Record<string, ModuleRegistryPair>>;\n\n/**\n * A callable registry is an object that describes the structure of\n * `ctx.modules`.\n *\n * If we have a registry like this:\n * - module `foo`\n *   - script `bar`\n *     - request type `BarRequest`\n *     - response type `BarResponse`\n *   - script `baz`\n *     - request type `BazRequest`\n *     - response type `BazResponse`\n * - module `fil`\n *   - script `qux`\n *     - request type `QuxRequest`\n *     - response type `QuxResponse`\n *   - script `cor`\n *     - request type `CorRequest`\n *     - response type `CorResponse`\n *\n * The callable registry would look like this:\n * ```ts\n * type CallableRegistry_TestReg = {\n *   foo: {\n *     bar: (req: BarRequest) => Promise<BarResponse>,\n *     baz: (req: BazRequest) => Promise<BazResponse>,\n *   },\n *   fil: {\n *     qux: (req: QuxRequest) => Promise<QuxResponse>,\n *     cor: (req: CorRequest) => Promise<CorResponse>,\n *   },\n * }\n * ```\n *\n * This is the type returned by the {@linkcode buildDependencyRegistryProxy} function.\n *\n * It is accessible to the user as `ctx.modules`.\n */\nexport type CallableDependencies<DependenciesT> = {\n\t[Mod in keyof DependenciesT]: {\n\t\t[Script in keyof DependenciesT[Mod]]: (\n\t\t\treq: RequestOf<DependenciesT[Mod][Script]>,\n\t\t) => Promise<ResponseOf<DependenciesT[Mod][Script]>>;\n\t};\n};\n\n/**\n * TODO: Comment\n */\nexport type ActorProxies<ActorDependenciesT> = {\n\t[Mod in keyof ActorDependenciesT]: {\n\t\t[Actor in keyof ActorDependenciesT[Mod]]: ActorProxy;\n\t};\n};\n\n/**\n * @param ctx The {@link Context} object to use to call the scripts in\n * accessible modules\n * @param map A {@link MapFrom} object that describes how to map\n * `[module, script] pairs from a camelCase registry to a snake_case registry\n * @returns A {@link CallableDependencies} object that implements the \"syntax sugar\"\n * that used in the `ctx.modules.<script>.<name>()` pattern to call scripts\n * without the `ctx.call` function.\n */\nexport function buildDependencyRegistryProxy<DependenciesSnakeT, DependenciesCamelT>(\n\tctx: Context<DependenciesSnakeT, DependenciesCamelT, any, any>,\n\tdependenciesMapCamelToSnake: RegistryCallMap,\n): CallableDependencies<DependenciesCamelT> {\n\tconst handler = {\n\t\tget: (_target: unknown, camelCaseModuleKey: string) => {\n\t\t\tif (camelCaseModuleKey in dependenciesMapCamelToSnake) {\n\t\t\t\tconst camelToSnakeMapForModule = dependenciesMapCamelToSnake[camelCaseModuleKey];\n\n\t\t\t\treturn new Proxy(camelToSnakeMapForModule, {\n\t\t\t\t\tget: (_target: unknown, scriptProp: string) => {\n\t\t\t\t\t\tif (scriptProp in camelToSnakeMapForModule) {\n\t\t\t\t\t\t\tconst [snakeCaseModule, snakeCaseScript] = camelToSnakeMapForModule[scriptProp];\n\t\t\t\t\t\t\treturn (req: unknown) => {\n\t\t\t\t\t\t\t\treturn ctx.call(\n\t\t\t\t\t\t\t\t\tsnakeCaseModule as any,\n\t\t\t\t\t\t\t\t\tsnakeCaseScript as any,\n\t\t\t\t\t\t\t\t\treq as any,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t};\n\treturn new Proxy({}, handler) as CallableDependencies<DependenciesCamelT>;\n}\n\nexport function buildActorRegistryProxy<ActorsSnakeT, ActorsCamelT>(\n\truntime: Runtime<any, any, ActorsSnakeT, ActorsCamelT>,\n\tactorMapCamelToSnake: RegistryCallMap,\n): ActorProxies<ActorsCamelT> {\n\t// TODO: Get rid of outer proxy (ctx.actors.foo.xxx -> ctx.actors.xxx)\n\tconst handler = {\n\t\tget: (_target: unknown, moduleProp: string) => {\n\t\t\tif (moduleProp in actorMapCamelToSnake) {\n\t\t\t\tconst moduleMap = actorMapCamelToSnake[moduleProp as keyof typeof actorMapCamelToSnake];\n\n\t\t\t\treturn new Proxy(moduleMap, {\n\t\t\t\t\tget: (_target: unknown, scriptProp: string) => {\n\t\t\t\t\t\tif (scriptProp in moduleMap) {\n\t\t\t\t\t\t\tconst pair = moduleMap[scriptProp as keyof typeof moduleMap];\n\t\t\t\t\t\t\treturn new ActorProxy(\n\t\t\t\t\t\t\t\truntime.actorDriver,\n\t\t\t\t\t\t\t\tpair[0] as any,\n\t\t\t\t\t\t\t\tpair[1] as any,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t};\n\treturn new Proxy({}, handler) as ActorProxies<ActorsCamelT>;\n}\n","src/runtime/runtime.ts":"import { addFormats, Ajv } from \"./deps.ts\";\nimport { ScriptContext } from \"./context.ts\";\nimport { Context, TestContext } from \"./context.ts\";\nimport { Postgres, PrismaClientDummy } from \"./postgres.ts\";\nimport { handleRequest } from \"./server.ts\";\nimport { TraceEntryType } from \"./trace.ts\";\nimport { newTrace } from \"./trace.ts\";\nimport { RegistryCallMap } from \"./proxy.ts\";\nimport { ActorDriver } from \"./actor.ts\";\n\nexport interface Config {\n\truntime: BuildRuntime;\n\tmodules: Record<string, Module>;\n\tcors?: CorsConfig;\n}\n\n/**\n * Which runtime to target when building.\n */\nexport enum BuildRuntime {\n\tDeno,\n\tCloudflare,\n}\n\nexport interface Module {\n\tscripts: Record<string, Script>;\n\tactors: Record<string, Actor>;\n\terrors: Record<string, ErrorConfig>;\n\tdb?: {\n\t\tname: string;\n\t\tcreatePrisma: (databaseUrl: string) => CreatePrismaOutput;\n\t};\n\tdependencies: Set<string>;\n\tuserConfig: unknown;\n}\n\nexport interface CorsConfig {\n\torigins: Set<string>;\n}\n\ninterface CreatePrismaOutput {\n\tprisma: PrismaClientDummy;\n\tpgPool?: any;\n}\n\nexport interface Script {\n\t// deno-lint-ignore no-explicit-any\n\trun: ScriptRun<any, any, any, any>;\n\t// deno-lint-ignore no-explicit-any\n\trequestSchema: any;\n\t// deno-lint-ignore no-explicit-any\n\tresponseSchema: any;\n\tpublic: boolean;\n}\n\nexport type ScriptRun<Req, Res, UserConfigT, DatabaseT> = (\n\tctx: ScriptContext<any, any, any, any, UserConfigT, DatabaseT>,\n\treq: Req,\n) => Promise<Res>;\n\nexport interface Actor {\n\tactor: any;\n\tstorageId: string;\n}\n\nexport interface ErrorConfig {\n\tdescription?: string;\n}\n\nexport class Runtime<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT> {\n\tpublic postgres: Postgres;\n\n\tpublic ajv: Ajv.default;\n\n\tpublic constructor(\n\t\tpublic config: Config,\n\t\tpublic actorDriver: ActorDriver,\n\t\tprivate dependencyCaseConversionMap: RegistryCallMap,\n\t\tprivate actorDependencyCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tthis.postgres = new Postgres();\n\n\t\tthis.ajv = new Ajv.default({\n\t\t\tremoveAdditional: true,\n\t\t});\n\t\t// TODO: Why are types incompatible\n\t\taddFormats.default(this.ajv as any);\n\t}\n\n\tprivate async shutdown() {\n\t\tawait this.postgres.shutdown();\n\t}\n\n\tpublic createRootContext(\n\t\ttraceEntryType: TraceEntryType,\n\t): Context<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT> {\n\t\treturn new Context(\n\t\t\tthis,\n\t\t\tnewTrace(traceEntryType, this.config.runtime),\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t\tthis.actorDependencyCaseConversionMap,\n\t\t);\n\t}\n\n\t/**\n\t * Serves the runtime as an HTTP server.\n\t */\n\tpublic async serve() {\n\t\tconst port = parseInt(Deno.env.get(\"PORT\") ?? \"6420\");\n\t\tconsole.log(`Serving on port ${port}`);\n\t\tawait Deno.serve(\n\t\t\t{ port },\n\t\t\t(req, info) => handleRequest(this, req, { remoteAddress: info.remoteAddr.hostname }),\n\t\t).finished;\n\t}\n\n\t/**\n\t * Registers a module test with the Deno runtime.\n\t */\n\tpublic static test<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT, UserConfigT>(\n\t\tconfig: Config,\n\t\tactorDriver: ActorDriver,\n\t\tmoduleName: string,\n\t\ttestName: string,\n\t\tfn: (\n\t\t\tctx: TestContext<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT, UserConfigT, any>,\n\t\t) => Promise<void>,\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t\tactorDependencyCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tDeno.test({\n\t\t\tname: testName,\n\n\t\t\t// TODO: https://github.com/rivet-gg/opengb-engine/issues/35\n\t\t\tsanitizeOps: false,\n\t\t\tsanitizeResources: false,\n\n\t\t\tasync fn() {\n\t\t\t\tconst runtime = new Runtime<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT>(\n\t\t\t\t\tconfig,\n\t\t\t\t\tactorDriver,\n\t\t\t\t\tdependencyCaseConversionMap,\n\t\t\t\t\tactorDependencyCaseConversionMap,\n\t\t\t\t);\n\n\t\t\t\t// Build context\n\t\t\t\tconst module = config.modules[moduleName];\n\t\t\t\tconst ctx = new TestContext<\n\t\t\t\t\tDependenciesSnakeT,\n\t\t\t\t\tDependenciesCamelT,\n\t\t\t\t\tActorsSnakeT,\n\t\t\t\t\tActorsCamelT,\n\t\t\t\t\tUserConfigT,\n\t\t\t\t\tPrismaClientDummy | undefined\n\t\t\t\t>(\n\t\t\t\t\truntime,\n\t\t\t\t\tnewTrace({\n\t\t\t\t\t\ttest: { module: moduleName, name: testName },\n\t\t\t\t\t}),\n\t\t\t\t\tmoduleName,\n\t\t\t\t\truntime.postgres.getOrCreatePool(module)?.prisma,\n\t\t\t\t\tdependencyCaseConversionMap,\n\t\t\t\t\tactorDependencyCaseConversionMap,\n\t\t\t\t);\n\n\t\t\t\t// Run test\n\t\t\t\ttry {\n\t\t\t\t\tawait ctx.runBlock(async () => {\n\t\t\t\t\t\tawait fn(ctx);\n\t\t\t\t\t});\n\t\t\t\t} catch (cause) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t`Failed to execute test: ${moduleName}.${testName}`,\n\t\t\t\t\t\tcause,\n\t\t\t\t\t);\n\t\t\t\t\tthrow cause;\n\t\t\t\t} finally {\n\t\t\t\t\tawait runtime.shutdown();\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Only runs on a CORS preflight requestâ€” returns a response with the\n\t * appropriate CORS headers & status.\n\t *\n\t * @param req The preflight OPTIONS request\n\t * @returns The full response to the preflight request\n\t */\n\tpublic corsPreflight(req: Request): Response {\n\t\tconst origin = req.headers.get(\"Origin\");\n\t\tif (origin) {\n\t\t\tconst normalizedOrigin = new URL(origin).origin;\n\t\t\tif (this.config.cors) {\n\t\t\t\tif (this.config.cors.origins.has(normalizedOrigin)) {\n\t\t\t\t\treturn new Response(undefined, {\n\t\t\t\t\t\tstatus: 204,\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t...this.corsHeaders(req),\n\t\t\t\t\t\t\t\"Vary\": \"Origin\",\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Origin is not allowed/no origin header on preflight\n\t\treturn new Response(\n\t\t\tJSON.stringify({\n\t\t\t\t\"message\": \"CORS origin not allowed. See https://opengb.dev/docs/cors\",\n\t\t\t}),\n\t\t\t{\n\t\t\t\tstatus: 403,\n\t\t\t\theaders: {\n\t\t\t\t\t\"Vary\": \"Origin\",\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\t}\n\n\tpublic corsHeaders(req: Request): Record<string, string> {\n\t\tconst origin = req.headers.get(\"Origin\");\n\n\t\t// Don't set CORS headers if there's no origin (e.g. a server-side\n\t\t// request)\n\t\tif (!origin) return {};\n\n\t\t// If the origin is allowed, return the appropriate headers.\n\t\t// Otherwise, return a non-matching cors header (empty object).\n\t\tif (this.config.cors?.origins.has(origin)) {\n\t\t\treturn {\n\t\t\t\t\"Access-Control-Allow-Origin\": new URL(origin).origin,\n\t\t\t\t\"Access-Control-Allow-Methods\": \"*\",\n\t\t\t\t\"Access-Control-Allow-Headers\": \"*\",\n\t\t\t};\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n\n\tpublic corsAllowed(req: Request): boolean {\n\t\tconst origin = req.headers.get(\"Origin\");\n\n\t\tif (!origin) return true;\n\t\treturn this.config.cors?.origins.has(origin) ?? false;\n\t}\n}\n","src/runtime/context.ts":"import { Runtime } from \"./runtime.ts\";\nimport { Trace } from \"./trace.ts\";\nimport { RuntimeError } from \"./error.ts\";\nimport { appendTraceEntry } from \"./trace.ts\";\nimport { buildActorRegistryProxy, buildDependencyRegistryProxy, RegistryCallMap } from \"./proxy.ts\";\nimport { DependencyScriptCallFunction } from \"../types/registry.ts\";\n\nexport class Context<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT> {\n\tpublic constructor(\n\t\tprotected readonly runtime: Runtime<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT>,\n\t\tpublic readonly trace: Trace,\n\t\tprivate readonly dependencyCaseConversionMap: RegistryCallMap,\n\t\tprotected readonly actorCaseConversionMap: RegistryCallMap,\n\t) {}\n\n\tprotected isAllowedModuleName(_moduleName: string): boolean {\n\t\treturn true;\n\t}\n\n\tpublic call: DependencyScriptCallFunction<this, DependenciesSnakeT> = async function (\n\t\tmoduleName,\n\t\tscriptName,\n\t\treq,\n\t) {\n\t\tconsole.log(\n\t\t\t`Request ${moduleName}.${scriptName}:\\n${JSON.stringify(req, null, 2)}`,\n\t\t);\n\n\t\ttry {\n\t\t\t// Check if calling module is allowed to call target module\n\t\t\tif (!this.isAllowedModuleName(moduleName)) {\n\t\t\t\tthrow new RuntimeError(\n\t\t\t\t\t\"CANNOT_ACCESS_MODULE\",\n\t\t\t\t\t{ cause: `Module \\`${moduleName}\\` is not a dependency` },\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Lookup module\n\t\t\tconst module = this.runtime.config.modules[moduleName];\n\t\t\tif (!module) throw new Error(`Module not found: ${moduleName}`);\n\n\t\t\t// Lookup script\n\t\t\tconst script = module.scripts[scriptName];\n\t\t\tif (!script) throw new Error(`Script not found: ${scriptName}`);\n\n\t\t\t// Build context\n\t\t\tconst ctx = new ScriptContext(\n\t\t\t\tthis.runtime,\n\t\t\t\tappendTraceEntry(this.trace, {\n\t\t\t\t\tscript: { module: moduleName, script: scriptName },\n\t\t\t\t}),\n\t\t\t\tmoduleName,\n\t\t\t\tthis.runtime.postgres.getOrCreatePool(module)?.prisma,\n\t\t\t\tscriptName,\n\t\t\t\tthis.dependencyCaseConversionMap,\n\t\t\t\tthis.actorCaseConversionMap,\n\t\t\t);\n\n\t\t\t// TODO: Replace with OGBE-15\n\t\t\t// // Compile schemas\n\t\t\t// const validateRequest = this.runtime.ajv.compile(script.requestSchema);\n\t\t\t// const validateResponse = this.runtime.ajv.compile(script.responseSchema);\n\n\t\t\t// // Validate request\n\t\t\t// if (!validateRequest(req)) {\n\t\t\t// \tthrow new Error(\n\t\t\t// \t\t`Invalid request: ${JSON.stringify(validateRequest.errors)}`,\n\t\t\t// \t);\n\t\t\t// }\n\n\t\t\t// Execute script\n\t\t\tconst res = await ctx.runBlock(async () => await script.run(ctx, req));\n\t\t\tconsole.log(\n\t\t\t\t`Response ${moduleName}.${scriptName}:\\n${JSON.stringify(res, null, 2)}`,\n\t\t\t);\n\n\t\t\t// TODO: Replace with OGBE-15\n\t\t\t// // Validate response\n\t\t\t// if (!validateResponse(res)) {\n\t\t\t// \tthrow new Error(\n\t\t\t// \t\t`Invalid response: ${JSON.stringify(validateResponse.errors)}`,\n\t\t\t// \t);\n\t\t\t// }\n\n\t\t\treturn res as any;\n\t\t} catch (cause) {\n\t\t\tconsole.warn(\n\t\t\t\t`Failed to execute script: ${moduleName}.${scriptName}`,\n\t\t\t\tcause,\n\t\t\t);\n\t\t\tthrow cause;\n\t\t}\n\t};\n\n\tpublic get modules() {\n\t\treturn buildDependencyRegistryProxy<DependenciesSnakeT, DependenciesCamelT>(\n\t\t\tthis,\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t);\n\t}\n\n\tpublic async tryCallRaw(\n\t\tmoduleName: string,\n\t\tscriptName: string,\n\t\treq: unknown,\n\t): Promise<object | null> {\n\t\t// Lookup module\n\t\tconst module = this.runtime.config.modules[moduleName];\n\t\tif (!module) return null;\n\n\t\t// Lookup script\n\t\tconst script = module.scripts[scriptName];\n\t\tif (!script) return null;\n\n\t\treturn await this.call(moduleName as any, scriptName as any, req as any);\n\t}\n\n\tpublic canCall(\n\t\tmoduleName: string,\n\t\tscriptName: string,\n\t\t_req?: unknown,\n\t): boolean {\n\t\t// Lookup module\n\t\tconst module = this.runtime.config.modules[moduleName];\n\t\tif (!module) return false;\n\n\t\t// Lookup script\n\t\tconst script = module.scripts[scriptName];\n\t\tif (!script) return false;\n\n\t\t// TODO: Replace with OGBE-15\n\t\t// const validateRequest = this.runtime.ajv.compile(script.requestSchema);\n\t\t// if (req && !validateRequest(req)) return false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Runs a block of code and catches any related errors.\n\t */\n\tpublic async runBlock<Res>(fn: () => Promise<Res>) {\n\t\ttry {\n\t\t\treturn await fn();\n\t\t} catch (cause) {\n\t\t\t// Convert error to RuntimeError. Enrich with context.\n\t\t\tif (cause instanceof RuntimeError) {\n\t\t\t\tcause.enrich(this.runtime, this);\n\t\t\t\tthrow cause;\n\t\t\t} else {\n\t\t\t\tconsole.error(\"Caught internal error:\", cause);\n\t\t\t\tconst error = new RuntimeError(\"INTERNAL_ERROR\", { cause });\n\t\t\t\terror.enrich(this.runtime, this);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Context for a module.\n */\nexport class ModuleContext<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT, UserConfigT, DatabaseT>\n\textends Context<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT> {\n\tpublic constructor(\n\t\truntime: Runtime<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT>,\n\t\ttrace: Trace,\n\t\tpublic readonly moduleName: string,\n\t\tpublic readonly db: DatabaseT,\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t\tactorCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tsuper(runtime, trace, dependencyCaseConversionMap, actorCaseConversionMap);\n\t}\n\n\tprotected isAllowedModuleName(targetModuleName: string): boolean {\n\t\treturn this.runtime.config\n\t\t\t.modules[this.moduleName]\n\t\t\t?.dependencies\n\t\t\t.has(targetModuleName);\n\t}\n\n\tpublic get config(): UserConfigT {\n\t\treturn this.runtime.config.modules[this.moduleName].userConfig as UserConfigT;\n\t}\n\n\tpublic get actors() {\n\t\treturn buildActorRegistryProxy<ActorsSnakeT, ActorsCamelT>(\n\t\t\tthis.runtime,\n\t\t\tthis.actorCaseConversionMap,\n\t\t);\n\t}\n}\n\n/**\n * Context for a script.\n */\nexport class ScriptContext<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT, UserConfigT, DatabaseT>\n\textends ModuleContext<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT, UserConfigT, DatabaseT> {\n\tpublic constructor(\n\t\truntime: Runtime<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT>,\n\t\ttrace: Trace,\n\t\tmoduleName: string,\n\t\tdb: DatabaseT,\n\t\tpublic readonly scriptName: string,\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t\tactorCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tsuper(runtime, trace, moduleName, db, dependencyCaseConversionMap, actorCaseConversionMap);\n\t}\n}\n\n/**\n * Context for a test.\n */\nexport class TestContext<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT, UserConfigT, DatabaseT>\n\textends ModuleContext<DependenciesSnakeT, DependenciesCamelT, ActorsSnakeT, ActorsCamelT, UserConfigT, DatabaseT> {}\n","src/runtime/postgres.ts":"import { QueryClient, Transaction } from \"./deps.ts\";\nimport { Module } from \"./runtime.ts\";\nimport { getDatabaseUrl } from \"../utils/db.ts\";\n\ntype PostgresRunScope<T> = (conn: QueryClient) => Promise<T>;\ntype PostgresTransactionScope<T> = (conn: Transaction) => Promise<T>;\n\nexport interface PrismaClientDummy {\n\t$disconnect(): Promise<void>;\n}\n\nexport interface Pool {\n\tprisma: PrismaClientDummy;\n\tpgPool?: any;\n}\n\n/** Manages Postgres connections. */\nexport class Postgres {\n\tprivate isShutDown = false;\n\n\tpublic pools = new Map<string, Pool>();\n\n\tpublic async shutdown() {\n\t\tthis.isShutDown = true;\n\t\tfor (const pool of this.pools.values()) {\n\t\t\tawait pool.prisma.$disconnect();\n\t\t\tif (pool.pgPool) await pool.pgPool.end();\n\t\t}\n\t}\n\n\tpublic getOrCreatePool(module: Module): Pool | undefined {\n\t\tif (!module.db) return undefined;\n\t\tif (this.isShutDown) throw new Error(\"Postgres is shutting down\");\n\n\t\tif (this.pools.has(module.db.name)) {\n\t\t\treturn this.pools.get(module.db.name)!;\n\t\t} else {\n\t\t\tconst url = getDatabaseUrl(module.db.name).toString();\n\n\t\t\t// Create & insert pool\n\t\t\tconst output = module.db.createPrisma(url);\n\t\t\tconst pool = {\n\t\t\t\tprisma: output.prisma,\n\t\t\t\tpgPool: output.pgPool,\n\t\t\t} as Pool;\n\t\t\tthis.pools.set(module.db.name, pool);\n\t\t\treturn pool;\n\t\t}\n\t}\n}\n\n/** Dummy type to represent places where we reference a specific database. */\nexport type PostgresWrapped<T> = T;\n","src/runtime/actor.ts":"export interface ActorDriver {\n\tgetId(moduleName: string, actorName: string, label: string): Promise<string>;\n\tgetActor(moduleName: string, actorName: string, label: string): Promise<any>;\n\tcreateActor(moduleName: string, actorName: string, label: string, input: any): Promise<void>;\n\tcallActor(stub: any, fn: string, ...args: any[]): Promise<any>;\n\tactorExists(moduleName: string, actorName: string, label: string): Promise<boolean>;\n}\n\n// Returned from ctx.actors.xxx\nexport class ActorProxy {\n\tconstructor(\n\t\tprivate driver: ActorDriver,\n\t\tprivate moduleName: string,\n\t\tprivate actorName: string,\n\t) {}\n\n\tget(label: string) {\n\t\treturn new ActorHandle(this.driver, this.moduleName, this.actorName, label);\n\t}\n\n\tasync exists(label: string) {\n\t\treturn await this.driver.actorExists(this.moduleName, this.actorName, label);\n\t}\n\n\tasync create(label: string, input: any) {\n\t\tawait this.driver.createActor(this.moduleName, this.actorName, label, input);\n\n\t\treturn new ActorHandle(this.driver, this.moduleName, this.actorName, label);\n\t}\n}\n\n// User-friendly class for handling actors\nclass ActorHandle {\n\tstub: any;\n\n\tconstructor(\n\t\tprivate driver: ActorDriver,\n\t\tprivate moduleName: string,\n\t\tprivate actorName: string,\n\t\tpublic label: string,\n\t) {}\n\n\tasync call(fn: string, ...args: any[]) {\n\t\tif (!this.stub) {\n\t\t\tthis.stub = await this.driver.getActor(this.moduleName, this.actorName, this.label);\n\t\t}\n\n\t\treturn await this.driver.callActor(this.stub, fn, args);\n\t}\n\n\tasync exists() {\n\t\treturn await this.driver.actorExists(this.moduleName, this.actorName, this.label);\n\t}\n}\n","src/runtime/mod.ts":"export * from \"./context.ts\";\nexport * from \"./error.ts\";\nexport * from \"./runtime.ts\";\nexport * from \"./trace.ts\";\n","src/runtime/error_test.ts":"import { unimplemented } from \"https://deno.land/std@0.208.0/assert/unimplemented.ts\";\nimport { assertEquals, assertExists } from \"../deps.ts\";\nimport { ActorDriver } from \"./actor.ts\";\nimport { ModuleContext } from \"./context.ts\";\nimport { RuntimeError } from \"./error.ts\";\nimport { BuildRuntime, newTrace } from \"./mod.ts\";\nimport { Runtime } from \"./runtime.ts\";\n\ntype DependenciesSnake = { test_module: Record<string, never> };\ntype DependenciesCamel = { testModule: Record<string, never> };\ninterface ActorsSnake {}\ninterface ActorsCamel {}\n\nexport const DUMMY_ACTOR_DRIVER: ActorDriver = {\n\tgetId(_moduleName: string, _actorName: string, _label: string): Promise<string> {\n\t\tunimplemented();\n\t},\n\tgetActor(_moduleName: string, _actorName: string, _label: string): Promise<any> {\n\t\tunimplemented();\n\t},\n\tcreateActor(_moduleName: string, _actorName: string, _label: string, _input: any): Promise<void> {\n\t\tunimplemented();\n\t},\n\tcallActor(_stub: any, _fn: string, ..._args: any[]): Promise<any> {\n\t\tunimplemented();\n\t},\n\tactorExists(_moduleName: string, _actorName: string, _label: string): Promise<boolean> {\n\t\tunimplemented();\n\t},\n};\n\nDeno.test(\"error\", async () => {\n\tconst dependencyCaseConversionMap = {\n\t\ttestModule: {},\n\t} as const;\n\tconst actorCaseConversionMap = {} as const;\n\n\t// Setup\n\tconst runtime = new Runtime<DependenciesSnake, DependenciesCamel, ActorsSnake, ActorsCamel>(\n\t\t{\n\t\t\truntime: BuildRuntime.Deno,\n\t\t\tmodules: {\n\t\t\t\ttest_module: {\n\t\t\t\t\tscripts: {},\n\t\t\t\t\tactors: {},\n\t\t\t\t\terrors: {\n\t\t\t\t\t\t\"TEST_ERROR\": {},\n\t\t\t\t\t},\n\t\t\t\t\tdependencies: new Set([\"test_module\"]),\n\t\t\t\t\tuserConfig: null,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tDUMMY_ACTOR_DRIVER,\n\t\tdependencyCaseConversionMap,\n\t\tactorCaseConversionMap,\n\t);\n\n\tconst moduleContext = new ModuleContext<\n\t\tDependenciesSnake,\n\t\tDependenciesCamel,\n\t\tActorsSnake,\n\t\tActorsCamel,\n\t\tnull,\n\t\tundefined\n\t>(\n\t\truntime,\n\t\tnewTrace({ internalTest: {} }),\n\t\t\"test_module\",\n\t\tundefined,\n\t\tdependencyCaseConversionMap,\n\t\tactorCaseConversionMap,\n\t);\n\n\t// Create error\n\tconst error = new RuntimeError(\"TEST_ERROR\");\n\tassertEquals(error.message.split(\"\\n\")[0], \"TEST_ERROR\");\n\n\t// Erich error\n\terror.enrich(runtime, moduleContext);\n\tassertExists(error.moduleName);\n\tassertExists(error.trace);\n\tassertExists(error.errorConfig);\n\tassertEquals(error.message.split(\"\\n\")[0], \"test_module[TEST_ERROR]\");\n});\n"}