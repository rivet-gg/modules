{
"sdk/godot/client/client.gd":"extends Node\nclass_name BackendClient\n## Low-level API used to build HTTP requests to the backend.\n\nconst _ApiRequest := preload(\"request.gd\")\n\nvar configuration: BackendConfiguration\n\nfunc _init(configuration: BackendConfiguration):\n\tself.configuration = configuration\n\n## Builds the headers for a request\nfunc _build_headers() -> PackedStringArray:\n\treturn [\n\t\t\"Accept: application/json\",\n\t\t\"Content-Type: application/json\",\n\t]\n\n## Builds the complete URL to the backend\nfunc _build_url(path: String) -> String:\n\tvar path_segments := path.split(\"/\", false)\n\treturn self.configuration.endpoint + \"/\" + \"/\".join(path_segments)\n\n## Creates a request\nfunc _request(method: HTTPClient.Method, path: String, body: Dictionary) -> _ApiRequest:\n\tif !self.is_inside_tree():\n\t\tpush_error(\"BackendClient node not added to tree, cannot make http requests\")\n\n\tvar url := self._build_url(path)\n\tvar body_json := JSON.stringify(body)\n\n\treturn _ApiRequest.new(self, method, url, { \n\t\t\"headers\": self._build_headers(), \n\t\t\"body\": body_json,\n\t})\n",
"sdk/godot/client/configuration.gd":"class_name BackendConfiguration\n## Backend configuration.\n\n## Endpoint to send requests to.\nvar endpoint: String = \"http://localhost:6420\"\n\nfunc _init():\n\tself.endpoint = _get_backend_endpoint()\n\tBackendLogger.log('Endpoint: %s' % self.endpoint)\n\n## Path of the configuration file bundled with a game from Rivet.\n##\n## This file is generated on deploy.\nconst RIVET_DEPLOYED_CONFIGURATION_FILE_PATH: String = \"res://.rivet_config.gd\"\n\n## Path of the configuration file when developing locally.\n##\n## This file is usually gitignored.\nconst RIVET_LOCAL_CONFIGURATION_FILE_PATH: String = \"res://.rivet/config.gd\"\n\n## Dynamically loads the configuration file with the backend endpoint.\nfunc _get_configuration():\n\tif FileAccess.file_exists(RIVET_DEPLOYED_CONFIGURATION_FILE_PATH):\n\t\tvar deployed_config_file = ResourceLoader.load(RIVET_DEPLOYED_CONFIGURATION_FILE_PATH)\n\t\tif deployed_config_file and 'new' in deployed_config_file:\n\t\t\tBackendLogger.log('Using endpoint from deployed config')\n\t\t\treturn deployed_config_file.new()\n\t\n\tif FileAccess.file_exists(RIVET_LOCAL_CONFIGURATION_FILE_PATH):\n\t\tvar deployed_config_file = ResourceLoader.load(RIVET_LOCAL_CONFIGURATION_FILE_PATH)\n\t\tif deployed_config_file and 'new' in deployed_config_file:\n\t\t\tBackendLogger.log('Using endpoint from local config')\n\t\t\treturn deployed_config_file.new()\n\n\treturn null\n\n## Derive the backend endpiont in order of priority:\n## - Environment variable (if running from deployed server)\n## - Configuration (if running in a client)\n## - Fallback to localhost\nfunc _get_backend_endpoint():\n\t# Use environment variable\n\tvar url_env = OS.get_environment(\"BACKEND_ENDPOINT\")\n\tif url_env:\n\t\tBackendLogger.log('Using endpoint from env')\n\t\treturn url_env\n\n\t# Use configuration shipped with game\n\tvar config = _get_configuration()\n\tif config:\n\t\treturn config.backend_endpoint\n\n\t# Fallback\n\tpush_warning(\"Could not find backend endpoint, falling back to localhost:6420\")\n\tBackendLogger.log('Using default endpoint')\n\treturn \"http://localhost:6420\"\n\n",
"sdk/godot/client/logger.gd":"class_name BackendLogger\n\nstatic func log(args):\n\tprint(\"[Backend] \", args)\n\nstatic func warning(args):\n\tpush_warning(\"[Backend] \", args)\n\nstatic func error(args):\n\tpush_error(\"[Backend] \", args)\n\n",
"sdk/godot/client/request.gd":"extends RefCounted\nclass_name BackendRequest\n## A wrapper around HTTPRequest that emits a signal when the request is completed.\n## This is a workaround for the fact that `HTTPRequest.request()` is blocking.\n## To run a request, create a new Request, connect to the completed signal,\n## and call `request().wait_completed()` to wait for the request to complete.\n\nconst _ApiResponse := preload(\"response.gd\")\n\nvar _started_at: int\nvar _method: HTTPClient.Method\nvar _url: String\n\nvar response: _ApiResponse = null\nvar _opts: Dictionary\nvar _http_request: HTTPRequest\n\nvar _success_callback: Callable\nvar _failure_callback: Callable\n\nsignal completed(response: _ApiResponse)\nsignal succeeded(response: _ApiResponse)\nsignal failed(response: _ApiResponse)\n\nfunc _init(owner: Node, method: HTTPClient.Method, url: String, opts: Variant = null):\n\tself._started_at = Time.get_ticks_msec()\n\tself._method = method\n\tself._url = url\n\n\tself._http_request = HTTPRequest.new()\n\tself._http_request.request_completed.connect(_on_request_completed)\n\tself._opts = {\n\t\t\"method\": method,\n\t\t\"url\": url,\n\t\t\"body\": opts.body,\n\t\t\"headers\": opts.headers,\n\t}\n\towner.add_child(self._http_request)\n\tself._http_request.request(_opts.url, _opts.headers, _opts.method, _opts.body)\n\nfunc set_success_callback(callback: Callable) -> BackendRequest:\n\tself._success_callback = callback\n\treturn self\n\nfunc set_failure_callback(callback: Callable) -> BackendRequest:\n\tself._failure_callback = callback\n\treturn self\n\nfunc _on_request_completed(result, response_code, headers, body):\n\tself.response = _ApiResponse.new(result, response_code, headers, body)\n\n\tvar finished_at = Time.get_ticks_msec()\n\tvar elapsed = finished_at - self._started_at\n\n\t# TODO: Print method, but Godot doesn't give method strings\n\tvar log_str = \"%s [Result: %s, HTTP: %s, Response: %s, Body: %sB, Elapsed: %sms]\" % [\n\t\tself._url,\n\t\tBackendResponse.Result.keys()[response.result],\n\t\tresponse.http_status,\n\t\tresponse.response_code,\n\t\tresponse.body_raw.size(),\n\t\telapsed,\n\t]\n\n\tif self.response.result == BackendResponse.Result.OK:\n\t\tBackendLogger.log(log_str)\n\telif self.response.result == BackendResponse.Result.BAD_REQUEST:\n\t\tBackendLogger.warning(log_str)\n\telse:\n\t\tBackendLogger.error(log_str)\n\n\t# Callbacks\n\tif result == OK:\n\t\tsucceeded.emit(response)\n\t\tif self._success_callback:\n\t\t\tself._success_callback.call(response)\n\telse:\n\t\tfailed.emit(response)\n\t\tif self._failure_callback:\n\t\t\tself._failure_callback.call(response)\n\tcompleted.emit(response)\n\n## Waits for the request to complete and returns the response in non-blocking way\nfunc async() -> _ApiResponse:\n\tawait completed\n\treturn response\n",
"sdk/godot/client/response.gd":"extends RefCounted\nclass_name BackendResponse\n## A response from the server. Contains the result, response code, headers, and body.\n## The body is a dictionary of the JSON response.\n\nenum Result {\n\tOK = 0,\n\tBAD_REQUEST = 1,\n\tINTERNAL_ERROR = 2,\n\tUNKNOWN_RESPONSE_CODE = 3,\n\tHTTP_ERROR = 4,\n\tJSON_PARSE_ERROR = 5,\n\tUNKNOWN = 6\n}\n\nvar result: Result:\n\tget:\n\t\tif http_status != HTTPClient.Status.STATUS_DISCONNECTED:\n\t\t\treturn Result.HTTP_ERROR\n\t\telif response_code >= 500 and response_code < 600:\n\t\t\treturn Result.INTERNAL_ERROR\n\t\telif response_code >= 400 and response_code < 500:\n\t\t\treturn Result.BAD_REQUEST\n\t\telif response_code == 200 and response_code < 500:\n\t\t\tif body != null:\n\t\t\t\treturn Result.OK\n\t\t\telse:\n\t\t\t\treturn Result.JSON_PARSE_ERROR\n\t\telif response_code > 0:\n\t\t\treturn Result.UNKNOWN_RESPONSE_CODE\n\t\telse:\n\t\t\treturn Result.UNKNOWN\n\n## Low-level HTTP response status cdoe.\nvar http_status: HTTPClient.Status\n\n## HTTP status code from response.\nvar response_code: HTTPClient.ResponseCode\n\n## The headers from the server.\nvar headers: PackedStringArray\n\n## The raw body of the response.\nvar body_raw: PackedByteArray\n\n## The parsed JSON body of the response.\n##\n## Will be null if failed to parse.\nvar body: Variant\n\nfunc _init(http_status: int, response_code: int, headers: PackedStringArray, response_body: PackedByteArray) -> void:\n\tself.http_status = http_status\n\tself.response_code = response_code\n\tself.headers = headers\n\t\n\tbody_raw = response_body\n\tvar json = JSON.new()\n\tvar error = json.parse(response_body.get_string_from_utf8())\n\tif error == OK:\n\t\tbody = json.get_data()\n\nfunc is_ok() -> bool:\n\treturn self.result == Result.OK\n\nfunc is_error() -> bool:\n\treturn !self.is_ok()\n\nfunc _to_string() -> String:\n\treturn \"BackendResponse [Result: %s, HTTP: %s, Response: %s, Body: %s]\" % [\n\t\tResult.keys()[result],\n\t\thttp_status,\n\t\tresponse_code,\n\t\tbody_raw.slice(0, 128).get_string_from_ascii()\n\t]\n\n",
"sdk/godot/plugin.cfg":"[plugin]\n\nname=\"Backend\"\ndescription=\"Auto-generated client for Open Game Backend (https://opengb.dev).\"\nauthor=\"\"\nversion=\"1.0.0\"\nscript = \"backend.gd\"\n\n",
"sdk/typescript/runtime.ts":"/* tslint:disable */\n/* eslint-disable */\n\nexport interface ConfigurationParameters {\n\tendpoint: string; // override base path\n\ttoken?: string | Promise<string> | ((name: string) => string | Promise<string>); // parameter for apiKey security\n\theaders?: HTTPHeaders; //header params we want to use on every request\n}\n\nexport class Configuration {\n\tconstructor(private configuration: ConfigurationParameters) {}\n\n\tget endpoint(): string {\n\t\treturn this.configuration.endpoint;\n\t}\n\n\tget token(): ((name: string) => string | Promise<string>) | undefined {\n\t\tconst token = this.configuration.token;\n\t\tif (token) {\n\t\t\treturn typeof token === \"function\" ? token : () => token;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tget headers(): HTTPHeaders | undefined {\n\t\treturn this.configuration.headers;\n\t}\n}\n\n/**\n * This is the base class for all generated API classes.\n */\nexport class BaseAPI {\n\tconstructor(protected configuration: Configuration) {\n\t}\n\n\tprotected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {\n\t\tconst { url, init } = await this.createFetchParams(context, initOverrides);\n\t\tconst response = await this.fetchApi(url, init);\n\n\t\tif (response && (response.status >= 200 && response.status < 300)) {\n\t\t\treturn response;\n\t\t}\n\n\t\tif (!response) throw new RequestError(\"No response received\");\n\n\t\tswitch (response.status) {\n\t\t\tcase 500:\n\t\t\t\tthrow new InternalError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 429:\n\t\t\t\tthrow new RateLimitError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 403:\n\t\t\t\tthrow new ForbiddenError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 408:\n\t\t\t\tthrow new UnauthorizedError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 404:\n\t\t\t\tthrow new NotFoundError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 400:\n\t\t\t\tthrow new BadRequestError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\tthrow new RequestError(undefined, undefined, await parseErrorBody(response));\n\t\t}\n\t}\n\n\tprivate async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {\n\t\tconst url = this.configuration.endpoint + context.path;\n\n\t\tconst headers = Object.assign({}, this.configuration.headers, context.headers);\n\t\tObject.keys(headers).forEach((key) => headers[key] === undefined ? delete headers[key] : {});\n\n\t\tconst initOverrideFn = typeof initOverrides === \"function\" ? initOverrides : async () => initOverrides;\n\n\t\tconst initParams = {\n\t\t\tmethod: context.method,\n\t\t\theaders,\n\t\t\tbody: context.body,\n\t\t};\n\n\t\tconst overriddenInit: RequestInit = {\n\t\t\t...initParams,\n\t\t\t...(await initOverrideFn({\n\t\t\t\tinit: initParams,\n\t\t\t\tcontext,\n\t\t\t})),\n\t\t};\n\n\t\tconst body = JSON.stringify(overriddenInit.body);\n\t\tconst init: RequestInit = {\n\t\t\t...overriddenInit,\n\t\t\tbody,\n\t\t};\n\n\t\treturn { url, init };\n\t}\n\n\tprivate fetchApi = async (url: string, init: RequestInit) => {\n\t\tconst fetchParams = { url, init };\n\t\tlet response: Response | undefined = undefined;\n\t\ttry {\n\t\t\tresponse = await fetch(fetchParams.url, fetchParams.init);\n\t\t} catch (err) {\n\t\t\tthrow new RequestError(\"Failed to make request\", undefined, undefined, { cause: err });\n\t\t}\n\t\treturn response;\n\t};\n}\n\nexport class RequestError extends Error {\n\tconstructor(message?: string, readonly statusCode?: number, readonly body?: unknown, options?: ErrorOptions) {\n\t\tsuper(buildMessage(message, statusCode, body), options);\n\t\t// Show as `Error`\n\t\tObject.setPrototypeOf(this, RequestError.prototype);\n\t}\n}\n\nexport class InternalError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"InternalError\",\n\t\t\t500,\n\t\t\tbody,\n\t\t);\n\t\t// Show as `Error`\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class RateLimitError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"RateLimitError\",\n\t\t\t429,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class ForbiddenError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"ForbiddenError\",\n\t\t\t403,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class UnauthorizedError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"UnauthorizedError\",\n\t\t\t408,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class NotFoundError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"NotFoundError\",\n\t\t\t404,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class BadRequestError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"BadRequestError\",\n\t\t\t400,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nfunction buildMessage(\n\tmessage: string | undefined,\n\tstatusCode: number | undefined,\n\tbody: unknown | undefined,\n): string {\n\tconst lines: string[] = [];\n\n\tif (message != null) {\n\t\tlines.push(message);\n\t}\n\tif (statusCode != null) {\n\t\tlines.push(`Status code: ${statusCode.toString()}`);\n\t}\n\tif (body != null) {\n\t\tlines.push(`Body: ${JSON.stringify(body, undefined, 2)}`);\n\t}\n\n\treturn lines.join(\"\\n\");\n}\n\nasync function parseErrorBody(response: Response) {\n\treturn await response.json();\n}\n\nexport type FetchAPI = WindowOrWorkerGlobalScope[\"fetch\"];\n\nexport type Json = any;\nexport type HTTPMethod = \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\" | \"OPTIONS\" | \"HEAD\";\nexport type HTTPHeaders = { [key: string]: string };\nexport type HTTPQuery = {\n\t[key: string]:\n\t\t| string\n\t\t| number\n\t\t| null\n\t\t| boolean\n\t\t| Array<string | number | null | boolean>\n\t\t| Set<string | number | null | boolean>\n\t\t| HTTPQuery;\n};\nexport type HTTPBody = Json | FormData | URLSearchParams;\nexport type HTTPRequestInit = {\n\theaders?: HTTPHeaders;\n\tmethod: HTTPMethod;\n\tcredentials?: RequestCredentials;\n\tbody?: HTTPBody;\n};\nexport type ModelPropertyNaming = \"camelCase\" | \"snake_case\" | \"PascalCase\" | \"original\";\n\nexport type InitOverrideFunction = (\n\trequestContext: { init: HTTPRequestInit; context: RequestOpts },\n) => Promise<RequestInit>;\n\nexport interface FetchParams {\n\turl: string;\n\tinit: RequestInit;\n}\n\nexport interface RequestOpts {\n\tpath: string;\n\tmethod: HTTPMethod;\n\theaders: HTTPHeaders;\n\tquery?: HTTPQuery;\n\tbody?: HTTPBody;\n}\n\nexport function querystring(params: HTTPQuery, prefix: string = \"\"): string {\n\treturn Object.keys(params)\n\t\t.map((key) => querystringSingleKey(key, params[key], prefix))\n\t\t.filter((part) => part.length > 0)\n\t\t.join(\"&\");\n}\n\nfunction querystringSingleKey(\n\tkey: string,\n\tvalue:\n\t\t| string\n\t\t| number\n\t\t| null\n\t\t| undefined\n\t\t| boolean\n\t\t| Array<string | number | null | boolean>\n\t\t| Set<string | number | null | boolean>\n\t\t| HTTPQuery,\n\tkeyPrefix: string = \"\",\n): string {\n\tconst fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n\tif (value instanceof Array) {\n\t\tconst multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue)))\n\t\t\t.join(`&${encodeURIComponent(fullKey)}=`);\n\t\treturn `${encodeURIComponent(fullKey)}=${multiValue}`;\n\t}\n\tif (value instanceof Set) {\n\t\tconst valueAsArray = Array.from(value);\n\t\treturn querystringSingleKey(key, valueAsArray, keyPrefix);\n\t}\n\tif (value instanceof Date) {\n\t\treturn `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n\t}\n\tif (value instanceof Object) {\n\t\treturn querystring(value as HTTPQuery, fullKey);\n\t}\n\treturn `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\n\nexport function mapValues(data: any, fn: (item: any) => any) {\n\treturn Object.keys(data).reduce(\n\t\t(acc, key) => ({ ...acc, [key]: fn(data[key]) }),\n\t\t{},\n\t);\n}\n"
}